{
  "id": "snapshot_1761526595988_768s63vss",
  "approvalId": "approval_1761526595806_wyjpz877r",
  "approvalTitle": "Phase 2 Requirements: Pydantic Integration (71.4% → 80-85%)",
  "version": 1,
  "timestamp": "2025-10-27T00:56:35.988Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThis specification addresses the gap between Phase 1 (71.4% validation success rate) and the 90% target by implementing **Pydantic-based validation** as the primary validation mechanism. Analysis shows that Pydantic models were generated in Phase 1 but never integrated into the validation pipeline. This phase implements Pydantic validation to replace JSON Schema validation, leveraging Pydantic's type coercion, field validators, and superior error messages to increase success rate from 71.4% to 80-85%.\n\n**Current State:**\n- YAML normalization success: 100% (59/59 unit tests passing)\n- End-to-end validation success: 71.4% (10/14 integration tests)\n- Pydantic models generated but unused (`src/models/strategy_models.py` exists but not called)\n- JSON Schema validation is redundant (Pydantic is superset of JSON Schema capabilities)\n\n**Target State:**\n- Phase 2 completion: 80-85% validation success rate\n- Pydantic as single source of truth for validation\n- Simplified architecture (remove JSON Schema validation redundancy)\n- Enhanced error messages with field paths\n\n## Alignment with Product Vision\n\nThis feature aligns with the Finlab Backtesting Optimization System's core principles:\n\n**避免過度工程化 (Avoid Over-Engineering):**\n- Removes redundant JSON Schema validation layer\n- Pydantic as single validation source (simpler architecture)\n- Reuses existing `strategy_models.py` (no new code generation)\n\n**從數據中學習 (Learn from Data):**\n- Analysis of Phase 1 shows 71.4% success with normalization alone\n- Integration testing identified gap: Pydantic models not utilized\n- Expert analysis confirms JSON Schema is redundant\n\n**漸進式改進 (Incremental Improvement):**\n- Phase 1 (Normalizer MVP): 71.4% → Phase 2 (Pydantic Integration): 80-85% → Phase 3 (Pipeline Integration): 85-90%\n- Build upon existing normalizer without breaking changes\n- Backward compatible with feature flags\n\n**自動化優先 (Automation First):**\n- Pydantic field validators provide automatic type coercion\n- Fail-fast with detailed error messages\n- No manual intervention required\n\n**Product Impact:**\n- **Validation Pass Rate**: From 71.4% → 80-85% (8.6-13.6% improvement)\n- **Architecture Simplicity**: Remove redundant JSON Schema layer\n- **Error Quality**: Better error messages for debugging\n- **Path to 90%**: Sets foundation for Phase 3 pipeline integration\n\n## Requirements\n\n### Requirement 1: Pydantic Validator Implementation\n\n**User Story:** As a developer running autonomous strategy optimization, I want Pydantic to be the primary validation mechanism, so that I get strict type checking with automatic coercion and superior error messages.\n\n#### Acceptance Criteria\n\n1. WHEN PydanticValidator is instantiated THEN it SHALL load the Strategy model from `src/models/strategy_models.py`\n   - **Evidence**: Pydantic models already generated in Phase 1 Task 3\n   - **Import**: `from src.models.strategy_models import Strategy`\n\n2. WHEN normalized YAML is validated THEN PydanticValidator SHALL call `Strategy.model_validate(normalized_data)`\n   - **Pattern**: `validated_strategy = Strategy.model_validate(data)`\n   - **Returns**: Pydantic Strategy instance if valid\n   - **Raises**: `pydantic.ValidationError` if invalid\n\n3. WHEN validation succeeds THEN PydanticValidator SHALL return validated data as dict using `model_dump(mode='json')`\n   - **Ensures**: Type coercion is applied (e.g., string '14' → int 14)\n   - **Ensures**: All fields conform to Pydantic model types\n   - **Format**: Clean JSON-serializable dict\n\n4. WHEN validation fails THEN PydanticValidator SHALL raise ValidationError with field paths\n   - **Example**: `indicators.technical_indicators.0.type: 'invalid' not in ['RSI', 'MACD', ...]`\n   - **Usage**: Clear error messages for debugging remaining failures\n\n5. IF Pydantic model has field validators THEN they SHALL execute during validation\n   - **Example**: Uppercase type conversion as double-insurance\n   - **Pattern**: `@field_validator('type', mode='before')`\n   - **Benefit**: Automatic corrections beyond normalization\n\n### Requirement 2: Replace JSON Schema Validation with Pydantic\n\n**User Story:** As a system maintainer, I want to remove the redundant JSON Schema validation layer, so that the architecture is simpler and Pydantic is the single source of truth.\n\n#### Acceptance Criteria\n\n1. WHEN YAMLSchemaValidator.validate() is called with normalize=True THEN it SHALL:\n   - Step 1: Call `normalize_yaml(yaml_spec)` (existing Phase 1 code)\n   - Step 2: Call `PydanticValidator.validate(normalized_spec)` (NEW)\n   - Step 3: Return (is_valid, errors) tuple\n   - **NO JSON Schema validation** (removed as redundant)\n\n2. WHEN PydanticValidator.validate() succeeds THEN YAMLSchemaValidator SHALL return `(True, [])`\n   - **Success Case**: Pydantic validation passes\n   - **No further validation needed**: Pydantic is stricter than JSON Schema\n\n3. WHEN PydanticValidator.validate() fails THEN YAMLSchemaValidator SHALL:\n   - Extract error messages from `pydantic.ValidationError`\n   - Format errors as list of strings (compatible with existing interface)\n   - Return `(False, error_messages)`\n   - **Log detailed errors**: Include field paths for debugging\n\n4. IF normalize=False THEN YAMLSchemaValidator SHALL skip normalization and use legacy JSON Schema validation\n   - **Backward Compatibility**: Support existing code paths\n   - **Feature Flag**: Allow gradual rollout\n   - **Safety**: No breaking changes to existing workflows\n\n5. WHEN all Phase 1 tests are run THEN they SHALL pass with normalize=False\n   - **Requirement**: 926 existing tests must pass (backward compatibility)\n   - **Validation**: Run `pytest` with normalizer disabled\n   - **Acceptance**: 100% pass rate\n\n### Requirement 3: Enhanced Error Handling and Logging\n\n**User Story:** As a developer debugging validation failures, I want detailed error messages with field paths, so that I can quickly identify and fix issues.\n\n#### Acceptance Criteria\n\n1. WHEN Pydantic validation fails THEN error messages SHALL include:\n   - Field path (e.g., `indicators.technical_indicators.0.type`)\n   - Expected type/value (e.g., `expected Literal['RSI', 'MACD', ...]`)\n   - Actual value (e.g., `got 'invalid'`)\n   - **Format**: Human-readable strings\n\n2. WHEN PydanticValidator logs errors THEN it SHALL use structured logging\n   - **Level**: WARNING for validation failures\n   - **Fields**: error_count, field_paths, error_types\n   - **Example**: `logger.warning(f\"Pydantic validation failed with {len(errors)} errors\")`\n\n3. WHEN validation succeeds THEN PydanticValidator SHALL log success\n   - **Level**: INFO for successful validations\n   - **Message**: \"Pydantic validation successful - Strategy model validated\"\n   - **Metric**: Count successful validations for monitoring\n\n4. IF normalization fails (NormalizationError) THEN it SHALL be logged separately\n   - **Distinction**: Separate normalization errors from validation errors\n   - **Action**: NormalizationError triggers retry (existing Phase 1 behavior)\n   - **Metric**: Track normalization vs. validation failure rates\n\n### Requirement 4: End-to-End Testing and Validation\n\n**User Story:** As a QA engineer, I want comprehensive testing to verify that Phase 2 achieves 80-85% success rate, so that we confirm the Pydantic integration delivers the expected improvement.\n\n#### Acceptance Criteria\n\n1. WHEN integration tests are run THEN success rate SHALL be ≥80% (Phase 2 target)\n   - **Baseline**: Phase 1 achieved 71.4% (10/14 fixtures)\n   - **Target**: Phase 2 should reach ≥80% (11-12/14 fixtures)\n   - **Test Set**: Same 14 fixtures from Phase 1 integration tests\n\n2. WHEN 20-30 iterations with real LLM API are executed THEN validation success rate SHALL be ≥80%\n   - **Test Script**: `python scripts/test_yaml_validation_phase2.py --iterations 30`\n   - **Real LLM**: Use Gemini 2.5 Flash or Grok for realistic testing\n   - **Measurement**: Count successful validations / total iterations\n\n3. WHEN tests compare baseline vs. Pydantic THEN improvement SHALL be measurable\n   - **Baseline (normalize=False)**: ~25% success rate (from original spec)\n   - **Phase 1 (normalize=True, no Pydantic)**: 71.4% success rate\n   - **Phase 2 (normalize=True + Pydantic)**: ≥80% success rate\n   - **Improvement**: +8.6% minimum from Phase 1\n\n4. IF success rate is <80% THEN failure analysis SHALL identify remaining issues\n   - **Categorize Failures**: By error type (structural, type, semantic)\n   - **Prioritize**: Identify highest-frequency failure patterns\n   - **Document**: Feed into Phase 3 Pipeline Integration planning\n\n5. WHEN all 926 existing tests are run THEN they SHALL pass (backward compatibility)\n   - **Command**: `pytest -v`\n   - **Requirement**: 100% pass rate with normalize=False\n   - **Safety**: Ensure no regressions\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n**Single Responsibility Principle:**\n- `src/generators/pydantic_validator.py`: Only Pydantic validation logic (no normalization, no schema)\n- `src/generators/yaml_schema_validator.py`: Orchestrates normalization + Pydantic validation\n- `src/models/strategy_models.py`: Only Pydantic models (no modification needed)\n\n**Modular Design:**\n- PydanticValidator is stateless (pure function: `validate(dict) -> Tuple[bool, list]`)\n- Can be tested independently of normalizer\n- Easy to replace or extend with new validation logic\n\n**Dependency Management:**\n- PydanticValidator depends only on `pydantic` (existing dependency) and `strategy_models.py`\n- YAMLSchemaValidator depends on PydanticValidator (new) and normalizer (existing)\n- Removes dependency on `jsonschema` validation (simplification)\n\n**Clear Interfaces:**\n```python\n# PydanticValidator Public API\nclass PydanticValidator:\n    def validate(self, data: dict) -> Tuple[bool, List[str]]:\n        \"\"\"\n        Validate data against Pydantic Strategy model.\n\n        Args:\n            data: Normalized YAML dict\n\n        Returns:\n            (is_valid, error_messages) tuple\n\n        Example:\n            >>> validator = PydanticValidator()\n            >>> is_valid, errors = validator.validate(normalized_data)\n            >>> if not is_valid:\n            ...     print(f\"Validation failed: {errors}\")\n        \"\"\"\n```\n\n### Performance\n\n**Pydantic Validation Speed:**\n- **Target**: <20ms per iteration (Pydantic is fast, typically 5-15ms)\n- **Measurement**: `pytest-benchmark` for validation\n- **Comparison**: Pydantic is faster than JSON Schema validation\n\n**Memory Overhead:**\n- **Target**: <2MB per iteration (Pydantic creates model instance + dict)\n- **Mitigation**: Model instances are short-lived (garbage collected immediately)\n\n**Integration Impact:**\n- **Net Performance**: Neutral or positive (removing JSON Schema validation offsets Pydantic cost)\n- **Total Overhead**: <1% of iteration time (validation is fast vs. backtest)\n\n### Security\n\n**Code Execution Safety:**\n- **No eval/exec**: Pydantic uses safe validation (no code execution)\n- **Input Validation**: Pydantic enforces strict types (prevents injection)\n- **Model Integrity**: Strategy model defines allowed fields (no arbitrary data)\n\n**Data Integrity:**\n- **Type Safety**: Pydantic ensures all fields have correct types\n- **Validation Chain**: Normalizer → Pydantic → Validated Model (two layers of defense)\n- **Immutability**: `model_dump()` creates clean copy (no original data mutation)\n\n### Reliability\n\n**Error Handling:**\n- **Explicit Exceptions**: `pydantic.ValidationError` for validation failures (clear signal)\n- **Logging**: Structured logging for all validation attempts (audit trail)\n- **Graceful Degradation**: Fall back to legacy validation if normalize=False\n\n**Backward Compatibility:**\n- **Feature Flag**: `normalize` parameter controls Pydantic validation\n- **Test Coverage**: 926 existing tests must pass (100% backward compatibility)\n- **Migration Path**: No data migration needed (stateless validation)\n\n**Monitoring:**\n- **Success Rate Tracking**: Log Pydantic validation success/failure counts\n- **Error Categorization**: Count each error type (type mismatch, missing field, etc.)\n- **Alert Threshold**: Warn if validation failure rate >15% (indicates regression)\n\n### Usability\n\n**Developer Experience:**\n- **Clear Error Messages**: Pydantic errors include field paths (e.g., \"indicators.technical_indicators.0.type\")\n- **Logging**: INFO-level logs show successful validations, WARNING for failures\n- **Testing**: Easy to add new test cases (use existing fixtures from Phase 1)\n\n**Integration Simplicity:**\n- **One-Line Validation**: `is_valid, errors = pydantic_validator.validate(data)`\n- **No Configuration Required**: Works out-of-box with existing strategy_models.py\n- **Optional Feature**: Controlled by `normalize` parameter (backward compatible)\n\n**Documentation:**\n- **API Docs**: Comprehensive docstrings (Google-style)\n- **Integration Guide**: Step-by-step modification of yaml_schema_validator.py\n- **Error Guide**: Common Pydantic errors and solutions in docs/TROUBLESHOOTING.md\n\n### Maintainability\n\n**Code Quality:**\n- **Type Hints**: All functions fully typed (mypy strict mode)\n- **PEP 8 Compliance**: flake8 passing, 100-char line length\n- **Test Coverage**: >80% for pydantic_validator.py, >90% for critical paths\n\n**Configuration Management:**\n- **No Configuration Needed**: Pydantic models are self-contained\n- **Feature Flag**: `normalize` parameter in YAMLSchemaValidator.validate()\n- **Easy to Extend**: Add field validators to strategy_models.py\n\n**Future-Proofing:**\n- **Schema Evolution**: Regenerate Pydantic models from updated schema (single command)\n- **Plugin Architecture**: Easy to add custom validators (inherit from PydanticValidator)\n- **Migration Path**: Can add additional validation layers without changing interface\n\n---\n\n**Document Version**: 1.0\n**Created**: 2025-10-27\n**Status**: Draft - Pending Approval\n**Owner**: Personal Project (週/月交易系統)\n**Estimated Effort**: 6-8 hours\n- Task 1: PydanticValidator Implementation (2h)\n- Task 2: YAMLSchemaValidator Integration (1.5h)\n- Task 3: Error Handling Enhancement (1h)\n- Task 4: E2E Testing (20-30 iterations) (1.5h)\n",
  "fileStats": {
    "size": 14212,
    "lines": 301,
    "lastModified": "2025-10-27T00:56:27.051Z"
  },
  "comments": []
}