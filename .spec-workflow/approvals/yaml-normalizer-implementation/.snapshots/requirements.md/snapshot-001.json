{
  "id": "snapshot_1761497303038_mlz8qmyoo",
  "approvalId": "approval_1761497302896_5csa7qczu",
  "approvalTitle": "Requirements: YAML Normalizer Implementation",
  "version": 1,
  "timestamp": "2025-10-26T16:48:23.038Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThis specification addresses a critical validation issue where LLM-generated YAML strategies have only 25% validation success rate despite 4 schema fixes. The root cause is a fundamental mismatch between prescriptive schema design and exploratory LLM generation patterns. This feature implements a two-stage validation architecture (Normalizer → Pydantic) to bridge this gap and achieve 90%+ success rate.\n\n**Current State:**\n- YAML schema validation success rate: 25% (5/20 iterations)\n- 40% of failures: `indicators` type mismatch (array vs object)\n- 30% of failures: Field naming mismatches (`length` vs `period`, `rule` vs `field`)\n- 15% of failures: Type enum violations (lowercase `sma` vs uppercase `SMA`)\n- Schema fixes (oneOf patterns) showed diminishing returns (0%→20%→40%→30%→25%)\n\n**Target State:**\n- Phase 1 (Normalizer MVP): 70-75% success rate\n- Phase 2 (Pydantic Integration): 80-85% success rate\n- Phase 3 (Pipeline Integration): 85-90% success rate\n- Phase 4 (Prompt Optimization): 90-95% success rate\n\n## Alignment with Product Vision\n\nThis feature aligns with the Finlab Backtesting Optimization System's core principles:\n\n**避免過度工程化 (Avoid Over-Engineering):**\n- MVP normalizer using 80/20 approach: handles top 5 error patterns (covers 95% of failures)\n- Regex-based transformations sufficient for current scale\n- No AST complexity needed for this phase\n\n**從數據中學習 (Learn from Data):**\n- Analysis of 15 real failure cases drives normalizer patterns\n- Empirical error distribution (40%/30%/15%/10%/5%) guides prioritization\n- TDD approach using actual LLM outputs\n\n**漸進式改進 (Incremental Improvement):**\n- Four-phase rollout with measurable success metrics\n- Build upon existing schema fixes (already at 25%)\n- Systematic progression: 25% → 70% → 85% → 90%+\n\n**自動化優先 (Automation First):**\n- Automatic normalization without human intervention\n- Integration into autonomous iteration loop\n- Fail-fast mechanism for unfixable cases (Jinja templates)\n\n**Product Impact:**\n- **Validation Pass Rate**: From 25% → 90%+ (target metric from product.md)\n- **Iteration Efficiency**: Reduce wasted iterations from validation failures\n- **Time Savings**: Eliminate manual YAML debugging and fixes\n- **System Quality**: Increase success rate towards >60% target\n\n## Requirements\n\n### Requirement 1: YAML Normalizer Core Implementation\n\n**User Story:** As a developer running autonomous strategy optimization, I want the system to automatically transform LLM-generated YAML into schema-compliant format, so that 90%+ of iterations pass validation without manual intervention.\n\n#### Acceptance Criteria\n\n1. WHEN LLM generates YAML with `indicators` as array THEN normalizer SHALL convert to `{technical_indicators: [...]}` object structure\n   - **Evidence**: 40% of failures (8/20 iterations) show this pattern\n   - **Test Cases**: Extract from `complete_validation_output.txt` iterations 1, 3, 5, 7, 9, 11, 13, 15\n\n2. WHEN LLM uses field aliases (`length`, `window`, `rule`, `order`) THEN normalizer SHALL map to canonical names (`period`, `field`, `method`)\n   - **Evidence**: 30% of failures show alias mismatches\n   - **Mapping Table**: `FIELD_ALIASES = {'length': 'period', 'window': 'period', 'rule': 'field', 'order': 'method'}`\n\n3. WHEN LLM generates `params` nested object THEN normalizer SHALL flatten params to top-level indicator properties\n   - **Example**: `{'type': 'RSI', 'params': {'length': 14}}` → `{'type': 'RSI', 'period': 14}`\n   - **Evidence**: Consistent pattern across all failures with indicators\n\n4. WHEN LLM uses lowercase indicator types (`sma`, `rsi`, `macd`) THEN normalizer SHALL uppercase and map to canonical types\n   - **Type Map**: `INDICATOR_TYPE_MAP = {'sma': 'SMA', 'ema': 'EMA', 'rsi': 'RSI', 'macd': 'MACD', 'macd_histogram': 'MACD', 'macd_signal': 'MACD'}`\n   - **Evidence**: 15% of failures show case mismatches\n\n5. WHEN normalized YAML contains Jinja templates (`{{`, `{%`) THEN normalizer SHALL raise `NormalizationError` to trigger retry\n   - **Rationale**: Jinja templates cannot be normalized (require re-generation)\n   - **Fail Fast**: Early detection prevents downstream validation errors\n\n6. WHEN normalized YAML is missing required fields (`metadata`, `indicators`, `entry_conditions`) THEN normalizer SHALL raise `NormalizationError`\n   - **Sanity Check**: Basic structure validation before Pydantic\n\n7. IF normalization succeeds THEN normalizer SHALL return deep-copied dict (no mutation of input)\n   - **Safety**: Preserve original for debugging/retry\n\n### Requirement 2: Pydantic Validation Models\n\n**User Story:** As a developer integrating normalized YAML, I want strict type validation with auto-generated Pydantic models, so that downstream code can safely assume valid structure without defensive checks.\n\n#### Acceptance Criteria\n\n1. WHEN Pydantic models are generated from schema THEN all enum types SHALL be enforced as Literal types\n   - **Example**: `type: Literal['RSI', 'MACD', 'SMA', 'EMA', 'ATR', 'ADX']`\n   - **Tool**: Use `datamodel-code-generator` CLI\n\n2. WHEN normalized YAML is validated THEN Pydantic SHALL apply field validators for automatic type conversions\n   - **Example**: Uppercase type conversion as double-insurance: `@field_validator('type', mode='before') def uppercase_type(cls, v): return v.upper() if isinstance(v, str) else v`\n\n3. WHEN validation fails THEN Pydantic SHALL return detailed error messages with field paths\n   - **Format**: `indicators.technical_indicators.0.type: 'invalid' not in ['RSI', 'MACD', ...]`\n   - **Usage**: Enable quick diagnosis of remaining 5-10% failures\n\n4. WHEN Pydantic models are instantiated THEN they SHALL support both object and array formats via discriminated unions\n   - **Pattern**: Handle `oneOf` scenarios from schema (entry_conditions, exit_conditions)\n\n### Requirement 3: Integration Point Analysis and Validation\n\n**User Story:** As a developer integrating the normalizer, I want clear understanding of insertion points in the existing pipeline, so that integration is minimal-risk and backward compatible.\n\n#### Acceptance Criteria\n\n1. WHEN integration points are identified THEN documentation SHALL map exact locations in `innovation_engine.py` and `llm_providers.py`\n   - **Expected Locations**:\n     - `InnovationEngine.generate_innovation()` - after YAML generation\n     - `LLMProvider._parse_yaml_response()` - before schema validation\n\n2. WHEN pytest is executed THEN existing test suite SHALL pass (926 tests) as baseline\n   - **Command**: `pytest -v`\n   - **Benchmark**: Establish pre-integration test health\n\n3. WHEN InnovationEngine code is reviewed THEN YAML generation flow SHALL be documented from LLM API call through validation\n   - **Diagram**: `LLM API → parse_yaml → [INSERT NORMALIZER HERE] → validate_schema → return strategy`\n\n4. IF insertion point modifies existing interface THEN backward compatibility SHALL be maintained\n   - **Pattern**: Wrapper function or optional parameter (e.g., `normalize=True`)\n\n5. WHEN normalizer integration is complete THEN new unit tests SHALL cover all transformation patterns (indicators, params, types, aliases)\n   - **Coverage Target**: >80% for `yaml_normalizer.py`\n\n### Requirement 4: Test-Driven Development with Real Failure Cases\n\n**User Story:** As a developer building the normalizer, I want comprehensive tests based on actual LLM failures, so that the solution addresses real-world issues rather than theoretical edge cases.\n\n#### Acceptance Criteria\n\n1. WHEN test suite is created THEN it SHALL include at least 15 real failure cases extracted from validation reports\n   - **Sources**:\n     - `complete_validation_output.txt` (20 iterations, 15 failures)\n     - `QUICKWINS_VALIDATION_REPORT.md` (additional 10 iterations, 7 failures)\n\n2. WHEN tests are written THEN each SHALL include:\n   - **Input**: Raw LLM-generated YAML (from failure logs)\n   - **Expected Output**: Schema-compliant normalized YAML\n   - **Assertion**: Validates against schema after normalization\n\n3. WHEN test categories are defined THEN they SHALL match error distribution:\n   - **Category 1** (40%): Array→object structure conversion (6 tests)\n   - **Category 2** (30%): Field alias mapping (5 tests)\n   - **Category 3** (15%): Type uppercase/mapping (3 tests)\n   - **Category 4** (10%): Nested params flattening (2 tests)\n   - **Category 5** (5%): Jinja/unfixable cases (1 test)\n\n4. WHEN TDD workflow is followed THEN each transformation SHALL:\n   - **Red**: Write failing test with real failure case\n   - **Green**: Implement minimal transformation to pass\n   - **Refactor**: Extract configuration (e.g., `FIELD_ALIASES`, `INDICATOR_TYPE_MAP`)\n\n### Requirement 5: Pipeline Integration and Backward Compatibility\n\n**User Story:** As a system maintainer, I want normalizer integration to be optional and backward compatible, so that existing workflows continue to function during rollout.\n\n#### Acceptance Criteria\n\n1. WHEN normalizer is integrated THEN it SHALL be behind a feature flag in configuration\n   - **Config**: `learning_system.yaml` → `yaml_normalization: enabled: true`\n   - **Default**: Enabled for new runs, manual opt-in for existing\n\n2. WHEN feature flag is disabled THEN existing validation flow SHALL execute unchanged\n   - **No Regression**: 926 tests pass with flag=false\n\n3. WHEN normalizer fails (raises `NormalizationError`) THEN system SHALL fall back to direct validation\n   - **Graceful Degradation**: Log warning but continue iteration\n   - **Metric Tracking**: Count normalization failures for monitoring\n\n4. WHEN integration is complete THEN success rate SHALL increase from 25% to 70%+ (Phase 1 target)\n   - **Measurement**: Run 10-iteration test with real LLM API\n   - **Acceptance**: ≥7/10 successful validations\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n**Single Responsibility Principle:**\n- `src/generators/yaml_normalizer.py`: Only normalization logic (no validation, no parsing)\n- `src/models/strategy_models.py`: Only Pydantic models (no transformation logic)\n- `tests/test_normalizer.py`: Only normalizer tests (no integration tests here)\n\n**Modular Design:**\n- Normalizer is stateless (pure function: `normalize_yaml(dict) -> dict`)\n- Configuration externalized (`FIELD_ALIASES`, `INDICATOR_TYPE_MAP` as module constants)\n- Easy to extend with new transformation patterns\n\n**Dependency Management:**\n- Normalizer depends only on Python stdlib (`copy`, `logging`, `typing`)\n- Pydantic models depend on schema (one-time generation)\n- Integration depends on normalizer + Pydantic (layered dependency)\n\n**Clear Interfaces:**\n```python\n# Public API\ndef normalize_yaml(raw_data: dict) -> dict:\n    \"\"\"\n    Transform LLM-generated YAML to schema-compliant format.\n\n    Args:\n        raw_data: Raw YAML dict from LLM\n\n    Returns:\n        Normalized YAML dict\n\n    Raises:\n        NormalizationError: If unfixable (Jinja, missing required fields)\n    \"\"\"\n```\n\n### Performance\n\n**Normalization Speed:**\n- **Target**: <10ms per iteration (negligible vs. 30-120s backtest)\n- **Measurement**: `pytest-benchmark` for all transformation patterns\n- **Bottlenecks**: Avoid regex in hot path, use dict lookups\n\n**Memory Overhead:**\n- **Target**: <1MB per iteration (YAML dicts are small, ~10-50KB)\n- **Deep Copy**: Acceptable trade-off for safety (no input mutation)\n\n**Integration Impact:**\n- **Target**: <1% increase in total iteration time (10ms / 60000ms = 0.017%)\n- **Negligible**: Backtest dominates runtime, normalization is noise\n\n### Security\n\n**Code Execution Safety:**\n- **No eval/exec**: Only dict manipulation (no code generation/execution)\n- **Input Validation**: Check for Jinja templates (potential injection risk)\n- **Fail Fast**: Reject suspicious patterns early\n\n**Data Integrity:**\n- **Deep Copy**: Input data never mutated (prevents side effects)\n- **Validation Chain**: Normalizer → Pydantic → Schema (three layers of defense)\n\n### Reliability\n\n**Error Handling:**\n- **Explicit Exceptions**: `NormalizationError` for unfixable cases (clear signal to retry)\n- **Logging**: Structured logging for all transformations (debug and audit trail)\n- **Graceful Degradation**: Fall back to direct validation if normalizer fails\n\n**Backward Compatibility:**\n- **Feature Flag**: Controlled rollout without breaking changes\n- **Test Coverage**: 926 existing tests must pass (100% backward compatibility)\n- **Migration Path**: No data migration needed (stateless transformation)\n\n**Monitoring:**\n- **Success Rate Tracking**: Log normalization success/failure counts\n- **Error Categorization**: Count each transformation pattern applied\n- **Alert Threshold**: Warn if normalization failure rate >20% (indicates new pattern)\n\n### Usability\n\n**Developer Experience:**\n- **Clear Error Messages**: `NormalizationError` includes specific reason (e.g., \"Contains Jinja templates at line 15\")\n- **Logging**: Info-level logs show transformations applied (e.g., \"Converted indicators array → object\")\n- **Testing**: Easy to add new test cases (just extract from failure logs)\n\n**Integration Simplicity:**\n- **One-Line Integration**: `normalized = normalize_yaml(raw_data)` before validation\n- **No Configuration Required**: Works out-of-box with sensible defaults\n- **Optional Advanced Config**: Override `FIELD_ALIASES` if needed (future extensibility)\n\n**Documentation:**\n- **API Docs**: Comprehensive docstrings (Google-style)\n- **Integration Guide**: Step-by-step insertion into `innovation_engine.py`\n- **Troubleshooting**: Common failures and solutions in docs/TROUBLESHOOTING.md\n\n### Maintainability\n\n**Code Quality:**\n- **Type Hints**: All functions fully typed (mypy strict mode)\n- **PEP 8 Compliance**: flake8 passing, 100-char line length\n- **Test Coverage**: >80% for normalizer module, >90% for critical paths\n\n**Configuration Management:**\n- **Centralized Constants**: All mappings in module top (`FIELD_ALIASES`, `INDICATOR_TYPE_MAP`)\n- **Easy to Extend**: Add new alias: just one line in `FIELD_ALIASES` dict\n- **No Magic Strings**: All hardcoded values extracted to constants\n\n**Future-Proofing:**\n- **Plugin Architecture**: Easy to add new transformation patterns (just add to `normalize_yaml()` function)\n- **Schema Evolution**: Pydantic models regenerated from schema (single command)\n- **Migration to AST**: Normalizer can be replaced module-by-module (clear interface)\n\n---\n\n**Document Version**: 1.0\n**Created**: 2025-10-27\n**Status**: Draft - Pending Approval\n**Owner**: Personal Project (週/月交易系統)\n**Estimated Effort**: 4.5 hours (Phase 1: 2h, Phase 2: 1h, Phase 3: 30min, Phase 4: 1h)\n",
  "fileStats": {
    "size": 14684,
    "lines": 298,
    "lastModified": "2025-10-26T16:48:15.462Z"
  },
  "comments": []
}