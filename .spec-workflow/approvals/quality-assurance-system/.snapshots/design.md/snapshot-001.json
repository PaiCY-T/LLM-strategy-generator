{
  "id": "snapshot_1762413527065_gjab54kt7",
  "approvalId": "approval_1762413526837_lg5gg3hd0",
  "approvalTitle": "Quality Assurance System - Design Document",
  "version": 1,
  "timestamp": "2025-11-06T07:18:47.065Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Quality Assurance System introduces a three-layer type safety and automation infrastructure:\n\n**Layer 1: Type Hints** - Function signature annotations using Python's standard typing module\n**Layer 2: Protocol Interfaces** - Structural type contracts defining component boundaries\n**Layer 3: Static Analysis + CI** - mypy enforcement with GitHub Actions automation\n\nThis design follows a **gradual, non-invasive adoption strategy** aligned with the project principle \"避免過度工程化\" (avoid over-engineering). Type hints are added incrementally to existing code without refactoring, Protocol interfaces document existing contracts, and CI automation runs in parallel without blocking development.\n\n**Key Design Principle**: Maximum safety with minimum disruption.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\n**Python 3.10+ Type Hints**:\n- Leverages PEP 484 (Type Hints), PEP 544 (Protocol), PEP 586 (Literal)\n- Modern type features: Union, Optional, Literal, TypedDict\n- Aligns with tech.md: \"Python 3.10+ for modern type hints\"\n\n**Code Quality Tools Integration**:\n- Extends existing mypy ≥1.18.0, pytest ≥8.4.0, flake8 ≥7.3.0\n- No new runtime dependencies (type hints are comments)\n- Dev dependencies only: mypy configuration\n\n**Testing Framework**:\n- Integrates with existing pytest setup (926 tests)\n- Adds E2E smoke tests to CI (test_phase8_e2e_smoke.py)\n- Maintains >80% code coverage requirement\n\n### Project Structure (structure.md)\n\n**File Organization**:\n```\nsrc/\n├── interfaces.py              # NEW: Central Protocol definitions\n├── learning/                  # MODIFIED: Add type hints\n│   ├── learning_loop.py\n│   ├── iteration_executor.py\n│   ├── iteration_history.py\n│   ├── champion_tracker.py\n│   └── feedback_generator.py\n├── backtest/                  # MODIFIED: Add type hints\n│   └── executor.py\n└── repository/                # MODIFIED: Add type hints\n    └── hall_of_fame.py\n\n.github/\n└── workflows/\n    └── quality-check.yml      # NEW: CI workflow\n\nmypy.ini                       # NEW: mypy configuration\n```\n\n**Naming Conventions**:\n- Protocol interfaces: `I` prefix (e.g., `IHistoryRepository`, `IChampionTracker`)\n- Follows structure.md PascalCase for classes, snake_case for functions\n- Type aliases: PascalCase (e.g., `MetricsDict`, `IterationNum`)\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n\n**Phase 8 E2E Test Suite** (`test_phase8_e2e_smoke.py`):\n- Already validates 8 critical integration points\n- 4 comprehensive tests (ChampionTracker init, update_champion API, full init, single iteration)\n- Will be integrated into CI without modification\n\n**Existing Development Tools**:\n- `mypy.ini` stub (exists but minimal configuration)\n- `requirements-dev.txt` (already includes mypy ≥1.18.0)\n- `pytest` infrastructure (926 tests, test runners configured)\n\n**Project Principles** (CLAUDE.md, product.md):\n- \"避免過度工程化\" - guides minimal configuration approach\n- \"80/20 principle\" - public APIs only, not 100% coverage\n- \"Gradual improvement\" - incremental type adoption\n\n### Integration Points\n\n**Development Workflow**:\n- Type checking integrates into existing `pytest` workflow\n- CI runs parallel to existing manual testing\n- IDE autocomplete enhancement (VSCode, PyCharm)\n\n**Existing Code**:\n- No breaking changes to public APIs\n- Type hints added as annotations only (no logic changes)\n- Backward compatible (Python ignores type hints at runtime)\n\n**Test Infrastructure**:\n- E2E tests run in GitHub Actions (same environment as pytest)\n- Coverage reports extend existing pytest-cov setup\n- No new test framework needed\n\n## Architecture\n\n### Three-Layer Quality Assurance Architecture\n\n```mermaid\ngraph TB\n    Dev[Developer Workflow] --> Layer1[Layer 1: Type Hints]\n    Layer1 --> Layer2[Layer 2: Protocol Interfaces]\n    Layer2 --> Layer3[Layer 3: Static Analysis]\n    Layer3 --> CI[GitHub Actions CI]\n\n    Layer1 --> IDE[IDE Autocomplete]\n    Layer2 --> Docs[Self-Documenting Code]\n    Layer3 --> Prevention[Error Prevention]\n    CI --> BlockMerge[Block Bad PRs]\n\n    subgraph \"Type Safety Layers\"\n        Layer1\n        Layer2\n        Layer3\n    end\n\n    subgraph \"Developer Benefits\"\n        IDE\n        Docs\n        Prevention\n    end\n\n    style Layer1 fill:#e1f5e1\n    style Layer2 fill:#fff4e6\n    style Layer3 fill:#e3f2fd\n    style CI fill:#ffe6e6\n```\n\n### Modular Design Principles\n\n**Single File Responsibility**:\n- `src/interfaces.py`: Protocol definitions ONLY (no implementations)\n- `mypy.ini`: Type checking configuration ONLY\n- `.github/workflows/quality-check.yml`: CI orchestration ONLY\n\n**Component Isolation**:\n- Type hints added per-module (IterationHistory, ChampionTracker independent)\n- Protocols defined separately from implementations (loose coupling)\n- CI job isolation (type-check job independent from test job)\n\n**Service Layer Separation**:\n- Interfaces layer (Protocols) separate from implementation\n- Configuration layer (mypy.ini) separate from code\n- Automation layer (CI) separate from development\n\n**Utility Modularity**:\n- Type aliases in interfaces.py (centralized definitions)\n- Common type patterns (MetricsDict, FilePath) reusable\n- Per-module mypy configuration (granular control)\n\n### Implementation Strategy: Bottom-Up Dependency Order\n\n```mermaid\ngraph BT\n    Tier1A[IterationHistory] --> Tier2A[ChampionTracker]\n    Tier1B[HallOfFameRepository] --> Tier2A\n    Tier1C[AntiChurnManager] --> Tier2A\n\n    Tier1D[LLMClient] --> Tier3A[IterationExecutor]\n    Tier1E[BacktestExecutor] --> Tier3A\n\n    Tier2A --> Tier3A\n    Tier2B[FeedbackGenerator] --> Tier3A\n\n    Tier3A --> Tier4[LearningLoop]\n\n    subgraph \"Tier 1: Dependencies\"\n        Tier1A\n        Tier1B\n        Tier1C\n        Tier1D\n        Tier1E\n    end\n\n    subgraph \"Tier 2: Dependents\"\n        Tier2A\n        Tier2B\n    end\n\n    subgraph \"Tier 3: Integrators\"\n        Tier3A\n    end\n\n    subgraph \"Tier 4: Orchestrators\"\n        Tier4\n    end\n\n    style Tier1A fill:#e1f5e1\n    style Tier1B fill:#e1f5e1\n    style Tier1C fill:#e1f5e1\n    style Tier1D fill:#e1f5e1\n    style Tier1E fill:#e1f5e1\n    style Tier2A fill:#fff4e6\n    style Tier2B fill:#fff4e6\n    style Tier3A fill:#e3f2fd\n    style Tier4 fill:#ffe6e6\n```\n\n**Rationale**: Type hints must be added from bottom to top to avoid forward references and circular imports. When typing `ChampionTracker`, the types for `IterationHistory`, `HallOfFameRepository`, and `AntiChurnManager` must already exist.\n\n## Components and Interfaces\n\n### Component 1: Central Interface Definitions (`src/interfaces.py`)\n\n- **Purpose:** Define Protocol interfaces for all core components, preventing circular imports and documenting contracts\n- **Interfaces:**\n  ```python\n  class IHistoryRepository(Protocol):\n      def get_all(self) -> List[IterationRecord]: ...\n      def save(self, record: IterationRecord) -> None: ...\n      def get_recent(self, n: int) -> List[IterationRecord]: ...\n\n  class IChampionTracker(Protocol):\n      def get_champion(self) -> Optional[IterationRecord]: ...\n      def update_champion(self, iteration_num: int, code: str,\n                         metrics: Dict[str, float]) -> bool: ...\n\n  class ILLMClient(Protocol):\n      def is_enabled(self) -> bool: ...\n      def generate(self, prompt: str) -> str: ...\n\n  class IBacktestExecutor(Protocol):\n      def execute(self, strategy_code: str, data: Any, sim: Any,\n                 **kwargs) -> ExecutionResult: ...\n\n  class IFeedbackGenerator(Protocol):\n      def generate_feedback(self, iteration_num: int,\n                           metrics: Optional[Dict[str, float]],\n                           execution_result: Dict[str, Any],\n                           classification_level: Optional[str],\n                           error_msg: Optional[str] = None) -> str: ...\n  ```\n- **Dependencies:** Python stdlib `typing` module only\n- **Reuses:** Standard PEP 544 Protocol pattern\n\n**Design Rationale**: Centralized interfaces prevent circular imports that often arise when components need to reference each other's types. Protocol enables structural subtyping (duck typing with type safety).\n\n### Component 2: mypy Configuration (`mypy.ini`)\n\n- **Purpose:** Configure gradual type checking with per-module strictness\n- **Interfaces:** Configuration file (not code)\n- **Dependencies:** mypy ≥1.18.0\n- **Reuses:** Standard mypy configuration format\n\n**Configuration Strategy**:\n```ini\n[mypy]\n# Lenient base configuration\npython_version = 3.11\nwarn_return_any = True\nwarn_unused_configs = True\nignore_missing_imports = True  # Don't fail on third-party without stubs\ndisallow_untyped_defs = False  # Gradual adoption\ncheck_untyped_defs = False     # Gradual adoption\n\n# Strict checking for fully typed core modules\n[mypy-src.interfaces]\ndisallow_untyped_defs = True\n\n[mypy-src.learning.iteration_history]\ndisallow_untyped_defs = True\ndisallow_incomplete_defs = True\n\n[mypy-src.learning.champion_tracker]\ndisallow_untyped_defs = True\ndisallow_incomplete_defs = True\n\n# Future: Enable strict mode for more modules as typed\n```\n\n**Design Rationale**: Lenient base configuration prevents \"boil the ocean\" problem (thousands of errors on untyped code). Per-module strictness enables gradual tightening as modules gain type coverage.\n\n### Component 3: GitHub Actions CI Workflow (`.github/workflows/quality-check.yml`)\n\n- **Purpose:** Automate type checking and E2E testing on every PR\n- **Interfaces:** GitHub Actions YAML workflow\n- **Dependencies:** Ubuntu runner, Python 3.11, mypy, pytest\n- **Reuses:** Standard GitHub Actions patterns\n\n**Workflow Design**:\n```yaml\nname: Quality Assurance Checks\n\non:\n  pull_request:\n    branches: [main]\n  push:\n    branches: [main]\n\njobs:\n  type-check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n      - name: Install dependencies\n        run: |\n          pip install --upgrade pip\n          pip install -r requirements.txt\n          pip install -r requirements-dev.txt\n      - name: Run mypy type checking\n        run: mypy src/\n\n  e2e-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-python@v4\n        with:\n          python-version: '3.11'\n      - name: Install dependencies\n        run: |\n          pip install --upgrade pip\n          pip install -r requirements.txt\n          pip install -r requirements-dev.txt\n      - name: Run E2E smoke tests\n        run: pytest test_phase8_e2e_smoke.py -v\n```\n\n**Design Rationale**: Parallel jobs (type-check and e2e-tests) for faster feedback. Separate jobs allow independent success/failure (e.g., type errors don't prevent running tests).\n\n### Component 4: Type Hints in Existing Modules\n\n- **Purpose:** Add type annotations to public APIs without changing logic\n- **Interfaces:** Enhanced function signatures with type hints\n- **Dependencies:** `typing` module, `src/interfaces.py` for Protocol types\n- **Reuses:** Existing code structure unchanged\n\n**Example Transformation** (`src/learning/iteration_history.py`):\n```python\n# BEFORE (untyped)\ndef get_all(self):\n    records = []\n    # ...\n    return records\n\ndef save(self, record):\n    # ...\n    with open(self.filepath, 'a') as f:\n        f.write(json.dumps(record_dict) + '\\n')\n\n# AFTER (typed)\ndef get_all(self) -> List[IterationRecord]:\n    records: List[IterationRecord] = []\n    # ...\n    return records\n\ndef save(self, record: IterationRecord) -> None:\n    # ...\n    with open(self.filepath, 'a') as f:\n        f.write(json.dumps(record_dict) + '\\n')\n```\n\n**Design Rationale**: Type hints are pure annotations (no runtime effect). Existing logic unchanged, only metadata added. If types are wrong, mypy catches it before runtime.\n\n## Data Models\n\n### Type Aliases (defined in `src/interfaces.py`)\n\n```python\nfrom typing import Dict, List, Optional, Any, Union\nfrom pathlib import Path\n\n# Common type aliases\nMetricsDict = Dict[str, float]\nFilePath = Union[str, Path]\nIterationNum = int\nStrategyCode = str\n\n# Result types\nExecutionResult = Any  # Will be properly typed in backtest/executor.py\nClassificationLevel = Literal[\"LEVEL_0\", \"LEVEL_1\", \"LEVEL_2\", \"LEVEL_3\"]\n```\n\n**Design Rationale**: Type aliases improve readability (`MetricsDict` vs `Dict[str, float]`) and enable centralized changes (if MetricsDict structure evolves).\n\n### IterationRecord Structure\n\nAlready exists as dataclass, will add full type hints:\n\n```python\n@dataclass\nclass IterationRecord:\n    iteration_num: int\n    generation_method: str\n    strategy_code: Optional[str]\n    strategy_id: Optional[str]\n    strategy_generation: Optional[int]\n    execution_result: Dict[str, Any]\n    metrics: Optional[MetricsDict]\n    classification_level: ClassificationLevel\n    timestamp: str\n    champion_updated: bool\n    feedback_used: str\n```\n\n### Configuration Types\n\n```python\nclass MyPyConfig(TypedDict, total=False):\n    python_version: str\n    warn_return_any: bool\n    ignore_missing_imports: bool\n    disallow_untyped_defs: bool\n```\n\n## Error Handling\n\n### Error Scenarios\n\n1. **Scenario: mypy Type Error on PR**\n   - **Handling:** CI fails with clear error message pointing to mismatch\n   - **User Impact:** Developer sees exact file:line and type mismatch, fixes before merge\n   - **Recovery:** Update code to match types or add `# type: ignore` comment if legitimate\n\n2. **Scenario: Circular Import from Type Hints**\n   - **Handling:** Use `from __future__ import annotations` and `TYPE_CHECKING` block\n   - **User Impact:** None (Python defers type annotation evaluation)\n   - **Example:**\n     ```python\n     from __future__ import annotations\n     from typing import TYPE_CHECKING\n\n     if TYPE_CHECKING:\n         from src.learning.champion_tracker import ChampionTracker\n\n     def process(tracker: ChampionTracker) -> None:\n         ...\n     ```\n\n3. **Scenario: Third-Party Library Without Type Stubs**\n   - **Handling:** `ignore_missing_imports = True` in mypy.ini base config\n   - **User Impact:** mypy doesn't fail on untyped dependencies (e.g., finlab)\n   - **Recovery:** Can add `# type: ignore` per-import or install type stubs if available\n\n4. **Scenario: E2E Test Failure in CI**\n   - **Handling:** CI fails, GitHub blocks merge with clear test output\n   - **User Impact:** Developer sees which of 4 E2E tests failed and why\n   - **Recovery:** Fix code to pass test, re-run CI\n\n5. **Scenario: False Positive from mypy**\n   - **Handling:** Developer can add `# type: ignore[specific-error]` comment\n   - **User Impact:** Unblocked after documenting reason for ignore\n   - **Example:**\n     ```python\n     result = func()  # type: ignore[no-untyped-call]  # Finlab library untyped\n     ```\n\n## Testing Strategy\n\n### Unit Testing\n\n**Approach:** Verify type checking catches known errors\n\n**Test Cases:**\n1. **Positive Test**: Correct types pass mypy\n   - Write test file with proper types\n   - Run `mypy test_file.py`\n   - Assert exit code 0 (success)\n\n2. **Negative Test**: Wrong types fail mypy\n   - Write test file with intentional type mismatch\n   - Run `mypy test_file.py`\n   - Assert exit code 1 (failure) and error message contains expected text\n\n**Example Test** (`tests/type_checking/test_mypy_validation.py`):\n```python\ndef test_correct_types_pass_mypy():\n    \"\"\"Verify properly typed code passes mypy.\"\"\"\n    test_code = '''\nfrom src.interfaces import IHistoryRepository\nfrom src.learning.iteration_history import IterationHistory\n\nhistory: IHistoryRepository = IterationHistory(filepath=\"test.jsonl\")\nrecords = history.get_all()  # Should return List[IterationRecord]\n'''\n    result = subprocess.run(['mypy', '-c', test_code], capture_output=True)\n    assert result.returncode == 0\n\ndef test_type_mismatch_fails_mypy():\n    \"\"\"Verify type mismatches are caught by mypy.\"\"\"\n    test_code = '''\nfrom src.interfaces import IChampionTracker\nfrom src.learning.champion_tracker import ChampionTracker\n\ntracker: IChampionTracker = ChampionTracker()\n# Wrong: update_champion expects (int, str, Dict), not (str, int, Dict)\ntracker.update_champion(\"wrong\", 123, {})  # Type error expected\n'''\n    result = subprocess.run(['mypy', '-c', test_code], capture_output=True)\n    assert result.returncode == 1\n    assert b\"Argument 1\" in result.stderr  # Error mentions wrong argument\n```\n\n### Integration Testing\n\n**Approach:** E2E smoke tests validate integration points (already exist)\n\n**Test Coverage** (`test_phase8_e2e_smoke.py`):\n1. **ChampionTracker Initialization**: Verifies all dependencies injected correctly\n2. **update_champion API**: Verifies correct parameter signature used\n3. **Full System Init**: Verifies all 8 components initialize without TypeError\n4. **Single Iteration**: Verifies complete flow executes end-to-end\n\n**CI Integration**:\n- E2E tests run in `e2e-tests` job\n- Fail if any test fails (4/4 must pass)\n- Test output visible in GitHub Actions UI\n\n### End-to-End Testing\n\n**Approach:** CI workflow exercises complete quality assurance pipeline\n\n**Test Scenario: PR Submission**\n1. Developer creates PR with code changes\n2. GitHub Actions triggers `quality-check` workflow\n3. Parallel jobs run:\n   - `type-check`: mypy validates types\n   - `e2e-tests`: Smoke tests validate integration\n4. Both jobs must succeed to merge\n5. If either fails, PR blocked with error details\n\n**Success Criteria**:\n- CI completes in <5 minutes\n- Clear error messages on failure\n- Zero false positives (legitimate code not blocked)\n\n**Regression Prevention**: If Phase 8 errors are reintroduced:\n- Fix #1, #2, #6: mypy catches parameter/method name mismatches\n- Fix #3: mypy catches missing required parameters\n- Fix #4: mypy catches wrong method signature\n- Fix #5: mypy catches wrong class type\n- Fix #7, #8: E2E tests catch runtime behavior changes\n\n## Migration Path\n\n### Phase 1: Foundation (Task 1-2)\n\n1. Create `src/interfaces.py` with 5 Protocol definitions\n2. Configure `mypy.ini` with lenient base + strict core modules\n3. Verify mypy runs successfully on existing code (may have warnings, no errors)\n\n**Success Criteria**: `mypy src/` exits with code 0 (warnings OK)\n\n### Phase 2: Type Tier 1 Modules (Task 3)\n\nAdd type hints to bottom-layer dependencies:\n- `src/learning/iteration_history.py`\n- `src/repository/hall_of_fame.py`\n- `src/config/anti_churn_manager.py`\n- `src/learning/llm_client.py`\n- `src/backtest/executor.py`\n\n**Success Criteria**: All Tier 1 modules pass mypy strict mode\n\n### Phase 3: Type Tier 2-4 Modules (Task 4-5)\n\nAdd type hints to higher layers:\n- Tier 2: `champion_tracker.py`, `feedback_generator.py`\n- Tier 3: `iteration_executor.py`\n- Tier 4: `learning_loop.py`\n\n**Success Criteria**: All core modules fully typed, mypy reports 0 errors\n\n### Phase 4: CI Automation (Task 6)\n\n1. Create `.github/workflows/quality-check.yml`\n2. Test workflow on draft PR\n3. Enable as required check for PRs to main\n\n**Success Criteria**: CI runs on test PR, reports pass/fail correctly\n\n### Phase 5: Documentation (Task 7)\n\nUpdate developer documentation:\n- README.md: Add \"Type Checking\" section\n- CONTRIBUTING.md: Add mypy instructions\n- CI badge: Add type-check status badge\n\n**Success Criteria**: Documentation complete, type checking visible to contributors\n\n## Dependencies and Integration\n\n**New Dependencies** (dev only):\n- None (mypy already in requirements-dev.txt ≥1.18.0)\n\n**Modified Files**:\n- `src/interfaces.py` (new)\n- `src/learning/*.py` (type hints added)\n- `src/backtest/executor.py` (type hints added)\n- `mypy.ini` (new configuration)\n- `.github/workflows/quality-check.yml` (new)\n\n**Integration Points**:\n- Existing pytest infrastructure (E2E tests)\n- Existing GitHub Actions (new workflow added)\n- Existing development workflow (type checking optional locally, enforced in CI)\n\n**Backward Compatibility**:\n- 100% compatible (type hints are annotations, no runtime effect)\n- Old code works unchanged (gradual typing)\n- No breaking changes to public APIs\n\n---\n\n**Document Version**: 1.0\n**Status**: Draft - Pending Approval\n**Last Updated**: 2025-11-06\n**Author**: Development Team\n**Reviewers**: TBD\n**Related Docs**:\n- Requirements Document (requirements.md)\n- Tech Stack (steering/tech.md)\n- Project Structure (steering/structure.md)\n- Phase 8 E2E Test Report (PHASE8_E2E_TEST_REPORT.md)\n",
  "fileStats": {
    "size": 20380,
    "lines": 622,
    "lastModified": "2025-11-06T07:18:37.201Z"
  },
  "comments": []
}