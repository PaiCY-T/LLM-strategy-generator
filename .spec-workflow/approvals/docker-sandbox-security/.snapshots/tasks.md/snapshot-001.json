{
  "id": "snapshot_1761396010810_2kxmgf3gs",
  "approvalId": "approval_1761396010729_wdflt8y0n",
  "approvalTitle": "Review tasks.md for docker-sandbox-security (15 tasks, 2-3 days)",
  "version": 1,
  "timestamp": "2025-10-25T12:40:10.810Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document: Docker Sandbox Security\n\n## Phase 1: Core Security Components (Tasks 1-4)\n\n- [ ] 1. Create SecurityValidator module\n  - File: `src/sandbox/security_validator.py`\n  - Implement AST-based code validation before Docker execution\n  - Detect dangerous imports (os.system, subprocess, eval, exec)\n  - Detect unauthorized file operations and network operations\n  - Purpose: First line of defense against code injection attacks\n  - _Leverage: `src/validation/ast_validator.py` for AST parsing patterns_\n  - _Requirements: 1.1, 1.2, 1.3_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Security Engineer specializing in Python code analysis and AST inspection | Task: Create SecurityValidator class following requirements 1.1-1.3, leveraging existing AST validation patterns from src/validation/ast_validator.py to detect dangerous imports, file operations, and network calls | Restrictions: Do not execute untrusted code during validation, maintain zero false negatives for dangerous operations, ensure validation completes in <100ms | _Leverage: src/validation/ast_validator.py for AST parsing utilities | _Requirements: Requirements 1.1 (AST validation), 1.2 (Dangerous import detection), 1.3 (File operation detection) | Success: All dangerous patterns are detected with >95% accuracy, validation is fast (<100ms), returns clear error messages for rejected code | Instructions: Set task status to [-] in tasks.md before starting, mark [x] when SecurityValidator passes all unit tests with >90% coverage_\n\n- [ ] 2. Create DockerConfig module\n  - File: `src/sandbox/docker_config.py`\n  - Implement configuration dataclass for Docker settings\n  - Load from `config/docker_config.yaml` with defaults\n  - Validate resource limits (memory, CPU, timeout)\n  - Purpose: Centralized configuration management for sandbox settings\n  - _Leverage: Existing YAML loading pattern from `config/learning_system.yaml`_\n  - _Requirements: 3.1, 3.2_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps Engineer with expertise in configuration management and Python dataclasses | Task: Create DockerConfig dataclass following requirements 3.1-3.2, using YAML loading patterns from existing config system, with validation for resource limits | Restrictions: Must provide sensible defaults, validate all numeric limits, ensure backward compatibility if config is missing | _Leverage: config/learning_system.yaml loading patterns | _Requirements: Requirement 3.1 (Configuration structure), 3.2 (YAML loading) | Success: Config loads from YAML with proper defaults, validation prevents invalid values, documented with all parameters | Instructions: Set task to [-] in tasks.md, mark [x] when DockerConfig unit tests pass_\n\n- [ ] 3. Create DockerExecutor module\n  - File: `src/sandbox/docker_executor.py`\n  - Implement container lifecycle management (create, run, cleanup)\n  - Apply resource limits (2GB memory, 0.5 CPU, 600s timeout)\n  - Configure security profiles (network isolation, read-only FS, seccomp)\n  - Purpose: Core execution engine for isolated strategy runs\n  - _Leverage: Python `docker` SDK, existing execution patterns from `src/backtest/executor.py`_\n  - _Requirements: 1.1, 1.2, 1.3, 1.4, 1.5_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with expertise in Docker SDK and containerization | Task: Implement DockerExecutor class following requirements 1.1-1.5, managing container lifecycle with strict resource limits and security profiles, wrapping existing backtest execution logic | Restrictions: Must cleanup containers even on failures, enforce 10min timeout strictly, handle Docker daemon unavailability gracefully | _Leverage: Python docker library, src/backtest/executor.py for execution patterns | _Requirements: Requirements 1.1 (Container isolation), 1.2 (Resource limits), 1.3 (Network isolation), 1.4 (Filesystem isolation), 1.5 (Auto cleanup) | Success: Containers are created with correct security settings, execution completes or timeouts properly, 100% cleanup success rate | Instructions: Set task to [-], mark [x] when DockerExecutor integration tests pass_\n\n- [ ] 4. Create ContainerMonitor module\n  - File: `src/sandbox/container_monitor.py`\n  - Implement container resource usage tracking\n  - Scan and cleanup orphaned containers from previous runs\n  - Export container metrics to Prometheus\n  - Purpose: Observability and resource leak prevention\n  - _Leverage: Existing `MetricsCollector` from `src/monitoring/metrics_collector.py`_\n  - _Requirements: 5.1, 5.2, 5.3, 5.4, 5.5_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: SRE with expertise in container monitoring and Prometheus instrumentation | Task: Create ContainerMonitor class following requirements 5.1-5.5, tracking container stats and detecting orphaned containers, integrating with existing Prometheus metrics | Restrictions: Must not impact container execution performance, handle Docker API timeouts gracefully, cleanup orphaned containers safely | _Leverage: src/monitoring/metrics_collector.py for Prometheus integration | _Requirements: Requirements 5.1 (Stats collection), 5.2 (Orphaned detection), 5.3 (Cleanup), 5.4 (Metrics export), 5.5 (Alerting) | Success: Container metrics are accurately exported, orphaned containers are detected and cleaned, monitoring overhead <1% | Instructions: Set task to [-], mark [x] when ContainerMonitor tests pass_\n\n## Phase 2: Configuration & Security Profiles (Tasks 5-6)\n\n- [ ] 5. Create Docker configuration file\n  - File: `config/docker_config.yaml`\n  - Define all Docker sandbox settings (image, limits, security)\n  - Document each configuration parameter\n  - Purpose: Production-ready configuration template\n  - _Leverage: Existing config structure from `config/learning_system.yaml`_\n  - _Requirements: All non-functional requirements_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps Engineer with expertise in Docker and YAML configuration | Task: Create comprehensive docker_config.yaml following all configuration requirements, documenting parameters with comments, providing production-ready defaults | Restrictions: Must include all parameters from design, use secure defaults, provide clear comments for each setting | _Leverage: config/learning_system.yaml for structure patterns | _Requirements: All configuration-related requirements | Success: Config file is complete with all parameters, well-documented, production-ready defaults | Instructions: Set task to [-], mark [x] when config validates and loads correctly_\n\n- [ ] 6. Create seccomp security profile\n  - File: `config/seccomp_profile.json`\n  - Define allowed/blocked system calls for containers\n  - Block dangerous syscalls (execve, fork, socket, etc.)\n  - Purpose: Kernel-level security enforcement\n  - _Leverage: Docker seccomp documentation and security best practices_\n  - _Requirements: 1.1 (Security isolation)_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Security Engineer with expertise in Linux syscalls and Docker security profiles | Task: Create seccomp profile following requirement 1.1, blocking dangerous syscalls while allowing necessary I/O operations, following Docker security best practices | Restrictions: Must block all process creation and network syscalls, allow file I/O for /tmp only, test profile doesn't break legitimate operations | _Leverage: Docker seccomp documentation | _Requirements: Requirement 1.1 (Security profiles) | Success: Profile blocks dangerous syscalls, allows necessary operations, container can execute strategies | Instructions: Set task to [-], mark [x] when profile is validated with test container_\n\n## Phase 3: Integration (Tasks 7-8)\n\n- [ ] 7. Integrate DockerExecutor into autonomous loop\n  - File: `artifacts/working/modules/autonomous_loop.py` (modify)\n  - Add sandbox mode configuration check\n  - Replace direct execution with DockerExecutor when enabled\n  - Implement fallback to direct execution on Docker failures (if configured)\n  - Purpose: Enable sandbox mode in production iteration loop\n  - _Leverage: Existing autonomous_loop.py structure, DockerExecutor module_\n  - _Requirements: 1.1, 1.2_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Backend Developer with expertise in Python and system integration | Task: Integrate DockerExecutor into autonomous_loop.py following requirements 1.1-1.2, checking sandbox config and routing execution through Docker or direct based on settings | Restrictions: Must not break existing direct execution mode, maintain backward compatibility, log all execution mode decisions | _Leverage: artifacts/working/modules/autonomous_loop.py, src/sandbox/docker_executor.py | _Requirements: Requirements 1.1 (Docker integration), 1.2 (Fallback mechanism) | Success: Loop uses Docker when enabled, falls back gracefully on failures, existing direct mode still works | Instructions: Set task to [-], mark [x] when integration tests pass for both sandbox and direct modes_\n\n- [ ] 8. Add sandbox configuration to learning system config\n  - File: `config/learning_system.yaml` (modify)\n  - Add `sandbox` section with enabled flag and Docker settings\n  - Document configuration options\n  - Purpose: Enable/disable sandbox mode in production\n  - _Leverage: Existing learning_system.yaml structure_\n  - _Requirements: All configuration requirements_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps Engineer with expertise in YAML configuration and feature flags | Task: Extend learning_system.yaml with sandbox configuration section, providing clear documentation and sensible defaults | Restrictions: Must maintain backward compatibility (default disabled), document all options clearly, follow existing YAML structure | _Leverage: config/learning_system.yaml | _Requirements: All configuration requirements | Success: Sandbox can be enabled/disabled via config, all settings documented, backward compatible | Instructions: Set task to [-], mark [x] when config schema is validated_\n\n## Phase 4: Testing (Tasks 9-13)\n\n- [ ] 9. Write SecurityValidator unit tests\n  - File: `tests/sandbox/test_security_validator.py`\n  - Test dangerous import detection (os.system, subprocess, eval, exec)\n  - Test file operation detection (/etc/passwd, /root access)\n  - Test network operation detection (socket, urllib, requests)\n  - Test valid code passes without errors\n  - Coverage target: >90%\n  - _Leverage: `pytest`, existing test utilities_\n  - _Requirements: 1.2, 1.3_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with expertise in security testing and pytest | Task: Create comprehensive unit tests for SecurityValidator covering requirements 1.2-1.3, testing detection of all dangerous patterns and ensuring valid code passes | Restrictions: Must test both positive (dangerous code rejected) and negative (valid code accepted) cases, achieve >90% coverage, run in <5s | _Leverage: pytest framework, tests/helpers/testUtils.ts | _Requirements: Requirements 1.2 (Import detection), 1.3 (File/network detection) | Success: All dangerous patterns detected, no false positives on valid code, >90% coverage | Instructions: Set task to [-], mark [x] when all tests pass and coverage >90%_\n\n- [ ] 10. Write DockerExecutor unit tests\n  - File: `tests/sandbox/test_docker_executor.py`\n  - Mock Docker daemon, test container creation with correct limits\n  - Test timeout enforcement with long-running mock container\n  - Test cleanup on both success and failure paths\n  - Test orphaned container detection\n  - Coverage target: >85%\n  - _Leverage: `pytest`, `unittest.mock` for Docker SDK mocking_\n  - _Requirements: 1.4, 1.5_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer with expertise in mocking and Docker testing | Task: Create unit tests for DockerExecutor following requirements 1.4-1.5, mocking Docker SDK to test lifecycle management and resource enforcement | Restrictions: Must mock all Docker API calls, test success and failure scenarios, ensure cleanup is always tested | _Leverage: pytest, unittest.mock for mocking docker.from_env() | _Requirements: Requirements 1.4 (Lifecycle management), 1.5 (Cleanup) | Success: All lifecycle scenarios tested with mocks, cleanup verified in all paths, >85% coverage | Instructions: Set task to [-], mark [x] when tests pass with >85% coverage_\n\n- [ ] 11. Write integration tests with real Docker containers\n  - File: `tests/integration/test_docker_sandbox.py`\n  - Test 1: Execute valid strategy in real container, verify results\n  - Test 2: Submit code with os.system, verify rejection before container creation\n  - Test 3: Submit memory-hungry code, verify container killed at limit\n  - Test 4: Submit network code, verify blocked by isolation\n  - Test 5: Verify filesystem isolation (read-only except /tmp)\n  - _Leverage: Real Docker daemon, pytest fixtures for container cleanup_\n  - _Requirements: All security and resource requirements_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Integration Test Engineer with expertise in Docker and system testing | Task: Create comprehensive integration tests using real Docker containers, validating all security and resource requirements end-to-end | Restrictions: Must cleanup containers after each test, tests must be idempotent, handle Docker daemon unavailability | _Leverage: Real Docker daemon, pytest fixtures for setup/teardown | _Requirements: All requirements (security, resources, isolation) | Success: All isolation mechanisms verified with real containers, tests pass consistently, proper cleanup | Instructions: Set task to [-], mark [x] when all 5 integration scenarios pass_\n\n- [ ] 12. Write autonomous loop integration tests\n  - File: `tests/integration/test_autonomous_loop_sandbox.py`\n  - Run 10 iterations with sandbox enabled\n  - Verify all strategies execute in Docker containers\n  - Verify no orphaned containers after run\n  - Verify metrics collected correctly\n  - _Leverage: Existing iteration loop test patterns_\n  - _Requirements: 1.1, 1.2_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Integration Test Engineer with expertise in end-to-end system testing | Task: Create autonomous loop integration tests following requirements 1.1-1.2, running multiple iterations with sandbox and verifying correct behavior | Restrictions: Must test real iteration loop, verify container usage, ensure cleanup, limit to 10 iterations for speed | _Leverage: Existing loop test patterns, pytest | _Requirements: Requirements 1.1 (Full integration), 1.2 (Production readiness) | Success: 10 iterations complete successfully, all in containers, no orphans, metrics accurate | Instructions: Set task to [-], mark [x] when integration test passes_\n\n- [ ] 13. Create performance benchmark tests\n  - File: `tests/performance/test_docker_overhead.py`\n  - Measure Docker vs direct execution overhead\n  - Test parallel container execution (5 simultaneous)\n  - Measure container creation and cleanup latency\n  - Verify <3s container creation, <5% execution overhead\n  - _Leverage: `pytest-benchmark` or timing utilities_\n  - _Requirements: Performance requirements_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Performance Engineer with expertise in benchmarking and profiling | Task: Create performance tests validating Docker overhead requirements, measuring creation time, execution overhead, and parallel performance | Restrictions: Must use consistent benchmarking methodology, run multiple iterations for accuracy, account for system variance | _Leverage: pytest-benchmark or time.perf_counter() | _Requirements: Performance requirement (container creation <3s, overhead <5%) | Success: Benchmarks show overhead within targets, parallel execution scales correctly, results documented | Instructions: Set task to [-], mark [x] when benchmarks meet performance targets_\n\n## Phase 5: Documentation & Deployment (Tasks 14-15)\n\n- [ ] 14. Create user documentation\n  - File: `docs/DOCKER_SANDBOX.md`\n  - Document installation requirements (Docker Engine 20.10+)\n  - Document configuration options\n  - Document troubleshooting (daemon issues, orphaned containers)\n  - Provide usage examples\n  - _Leverage: Existing documentation structure_\n  - _Requirements: All_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Technical Writer with expertise in developer documentation | Task: Create comprehensive user documentation covering installation, configuration, usage, and troubleshooting of Docker sandbox feature | Restrictions: Must be clear for both novice and experienced users, include real examples, maintain consistent structure with existing docs | _Leverage: Existing documentation structure and style | _Requirements: All requirements (user needs complete docs) | Success: Documentation is complete, clear, includes examples, users can set up sandbox successfully | Instructions: Set task to [-], mark [x] when documentation review passes_\n\n- [ ] 15. Create deployment checklist and scripts\n  - File: `scripts/setup_docker_sandbox.sh`\n  - Create automated setup script for Docker sandbox\n  - Verify Docker installation and version\n  - Build Python base image with FinLab dependencies\n  - Validate seccomp profile and configuration\n  - _Leverage: Shell scripting, Docker build commands_\n  - _Requirements: Deployment requirements_\n  - _Prompt: Implement the task for spec docker-sandbox-security, first run spec-workflow-guide to get the workflow guide then implement the task: Role: DevOps Engineer with expertise in Docker and deployment automation | Task: Create automated deployment script that verifies Docker setup, builds base image, and validates configuration, ensuring production readiness | Restrictions: Must check prerequisites before proceeding, provide clear error messages, be idempotent (safe to re-run) | _Leverage: bash scripting, docker build, docker inspect | _Requirements: Deployment requirements (Docker 20.10+, image build, validation) | Success: Script automates complete setup, validates all requirements, provides clear success/failure messages | Instructions: Set task to [-], mark [x] when script successfully deploys sandbox on clean system_\n\n## Summary\n\n**Total Tasks**: 15\n**Estimated Time**: 2-3 days (full-time)\n\n**Phase Breakdown**:\n- Phase 1 (Core): Tasks 1-4 → 8-10 hours\n- Phase 2 (Config): Tasks 5-6 → 2-3 hours\n- Phase 3 (Integration): Tasks 7-8 → 3-4 hours\n- Phase 4 (Testing): Tasks 9-13 → 8-10 hours\n- Phase 5 (Docs): Tasks 14-15 → 2-3 hours\n\n**Dependencies**:\n- Tasks 1-2 can run in parallel\n- Task 3 depends on Task 2 (needs DockerConfig)\n- Task 4 depends on Task 3 (needs DockerExecutor)\n- Tasks 5-6 can run in parallel with Tasks 1-4\n- Tasks 7-8 depend on Tasks 1-4 complete\n- Tasks 9-13 depend on respective implementation tasks\n- Tasks 14-15 depend on all previous tasks\n\n**Critical Path**: 1→3→7→11→15\n",
  "fileStats": {
    "size": 20205,
    "lines": 185,
    "lastModified": "2025-10-25T00:12:51.812Z"
  },
  "comments": []
}