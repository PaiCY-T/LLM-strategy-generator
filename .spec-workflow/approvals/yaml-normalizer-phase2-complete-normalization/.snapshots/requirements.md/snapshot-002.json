{
  "id": "snapshot_1761531994300_qjyvyb3dm",
  "approvalId": "approval_1761531654412_d9ntx1cx2",
  "approvalTitle": "Phase 2: Complete Normalization & Validation (71.4% → 85-87%)",
  "version": 2,
  "timestamp": "2025-10-27T02:26:34.300Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nThis specification addresses the gap between Phase 1 (71.4% validation success rate) and the 90% target by **completing the normalization layer** and integrating **Pydantic-based validation**.\n\n**Critical Finding from Phase 1 Analysis**: All 4 integration test failures (4/14 = 28.6%) are caused by indicator `name` field violating schema pattern `^[a-z_][a-z0-9_]*$`. LLM outputs use uppercase names (e.g., \"SMA_Fast\", \"RSI\") but schema requires lowercase (e.g., \"sma_fast\", \"rsi\"). The Phase 1 normalizer lacks name normalization logic.\n\n**Key Insight**: Pydantic validation alone **cannot** fix pattern violations - it validates but doesn't transform. The solution requires **enhancing the normalizer** to handle name transformation, then adding Pydantic for strict validation.\n\n**Current State:**\n- YAML normalization: 100% unit tests passing (59/59)\n- End-to-end validation: 71.4% (10/14 integration tests)\n- **Root Cause**: Missing name normalization in Phase 1\n- **Evidence**: All 4 failures share identical error: \"name field does not match pattern\"\n\n**Target State:**\n- Phase 2 completion: 85-87% validation success rate\n- Complete normalizer with all transformations\n- Pydantic as single validation source (replacing JSON Schema)\n- Enhanced error messages with field paths\n\n**Detailed Analysis**: See `/mnt/c/Users/jnpi/documents/finlab/PHASE1_FAILURE_ANALYSIS.md`\n\n## Alignment with Product Vision\n\nThis feature aligns with the Finlab Backtesting Optimization System's core principles:\n\n**避免過度工程化 (Avoid Over-Engineering):**\n- Simple name normalization (lowercase + replace spaces)\n- Remove redundant JSON Schema validation layer\n- Reuse existing `strategy_models.py` (no regeneration needed)\n\n**從數據中學習 (Learn from Data):**\n- **Evidence-based approach**: Analysis of 4/14 actual failures\n- Root cause identified through systematic investigation\n- Solution targets verified pain points, not theoretical issues\n\n**漸進式改進 (Incremental Improvement):**\n- Phase 1 (Normalizer MVP): 71.4% ✓\n- Phase 2 (Complete Normalization + Validation): 85-87%\n- Phase 3 (Pipeline Integration): 90%+\n- Each phase builds on previous work without breaking changes\n\n**自動化優先 (Automation First):**\n- Automatic name transformation (no manual fixes)\n- Pydantic field validators for type coercion\n- Fail-fast with actionable error messages\n\n**Product Impact:**\n- **Validation Pass Rate**: From 71.4% → 85-87% (+13.6-15.6%)\n- **Architecture Simplicity**: Single validation source (Pydantic)\n- **Error Quality**: Field-path specific error messages\n- **Path to 90%**: Solid foundation for Phase 3 pipeline integration\n\n## Requirements\n\n### Requirement 1: Enhanced Normalizer with Name Transformation\n\n**User Story:** As a developer running autonomous strategy optimization, I want the normalizer to transform indicator names to match schema patterns, so that LLM-generated uppercase names don't cause validation failures.\n\n#### Acceptance Criteria\n\n1. WHEN normalizer processes indicator names THEN it SHALL convert to lowercase\n   - **Pattern**: `\"SMA_Fast\"` → `\"sma_fast\"`, `\"RSI\"` → `\"rsi\"`\n   - **Evidence**: All 4 failed cases have uppercase names\n   - **Coverage**: technical_indicators, fundamental_factors, custom_calculations\n\n2. WHEN indicator names contain spaces THEN normalizer SHALL replace with underscores\n   - **Pattern**: `\"SMA Fast\"` → `\"sma_fast\"`\n   - **Robustness**: Handle edge cases from LLM variations\n   - **Consistency**: Ensure valid Python identifiers\n\n3. WHEN normalizer transforms names THEN it SHALL log transformations\n   - **Level**: DEBUG for name transformations\n   - **Message**: `\"Normalized indicator name: 'SMA_Fast' → 'sma_fast'\"`\n   - **Metric**: Count name transformations applied\n\n4. WHEN names are already lowercase THEN normalizer SHALL leave unchanged\n   - **Efficiency**: Skip transformation if pattern already matches\n   - **Idempotency**: Repeated normalization produces same result\n   - **Test**: Verify no unnecessary transformations\n\n5. IF name transformation produces invalid identifier THEN normalizer SHALL raise NormalizationError\n   - **Example**: Empty string, starts with digit, contains invalid chars\n   - **Safety**: Fail fast on edge cases\n   - **Message**: Clear indication of what's invalid\n\n### Requirement 2: Pydantic Validator Implementation\n\n**User Story:** As a system maintainer, I want Pydantic to be the primary validation mechanism, so that validation is strict, errors are clear, and architecture is simplified.\n\n#### Acceptance Criteria\n\n1. WHEN PydanticValidator is instantiated THEN it SHALL load Strategy model from `src/models/strategy_models.py`\n   - **Import**: `from src.models.strategy_models import Strategy`\n   - **Reuse**: Leverage models generated in Phase 1 Task 3\n   - **No Changes**: Existing Pydantic models work as-is\n\n2. WHEN normalized YAML is validated THEN PydanticValidator SHALL call `Strategy.model_validate(normalized_data)`\n   - **Returns**: Pydantic Strategy instance if valid\n   - **Raises**: `pydantic.ValidationError` if invalid\n   - **Type Coercion**: Automatic conversion (e.g., string '14' → int 14)\n\n3. WHEN validation succeeds THEN PydanticValidator SHALL return `(True, [])`\n   - **Tuple**: Compatible with existing YAMLSchemaValidator interface\n   - **Clean Data**: Use `model_dump(mode='json')` for downstream consumption\n   - **Log**: INFO level success message\n\n4. WHEN validation fails THEN PydanticValidator SHALL extract and format Pydantic errors\n   - **Field Paths**: Include full path (e.g., `indicators.technical_indicators.0.type`)\n   - **Expected/Actual**: Show what was expected vs. what was received\n   - **Human Readable**: Format as list of strings\n   - **Return**: `(False, error_messages)`\n\n5. IF Pydantic model has field validators THEN they SHALL execute automatically\n   - **Example**: Uppercase type conversion as double-insurance\n   - **Benefit**: Additional automatic corrections beyond normalization\n   - **Pattern**: `@field_validator('type', mode='before')`\n\n### Requirement 3: Replace JSON Schema Validation\n\n**User Story:** As a system architect, I want to remove the redundant JSON Schema validation layer, so that Pydantic is the single source of truth and architecture is simpler.\n\n#### Acceptance Criteria\n\n1. WHEN YAMLSchemaValidator.validate() is called with normalize=True THEN it SHALL:\n   - **Step 1**: Call `normalize_yaml(yaml_spec)` (enhanced with name normalization)\n   - **Step 2**: Call `PydanticValidator.validate(normalized_spec)` (NEW)\n   - **Step 3**: Return `(is_valid, errors)` tuple\n   - **Removed**: JSON Schema validation (redundant, Pydantic is stricter)\n\n2. WHEN both normalizer and Pydantic succeed THEN validation SHALL return `(True, [])`\n   - **Success Path**: No further validation needed\n   - **Performance**: Faster than previous two-stage validation\n   - **Simplicity**: One validation source\n\n3. WHEN normalizer fails (NormalizationError) THEN validation SHALL:\n   - **Catch**: NormalizationError exception\n   - **Log**: WARNING with error details\n   - **Return**: `(False, [error_message])`\n   - **No Retry Here**: Retry logic belongs in Phase 3 pipeline integration\n\n4. WHEN Pydantic fails (ValidationError) THEN validation SHALL:\n   - **Extract**: Error messages from Pydantic exception\n   - **Format**: Convert to list of strings\n   - **Log**: WARNING with field paths\n   - **Return**: `(False, error_messages)`\n\n5. IF normalize=False THEN YAMLSchemaValidator SHALL use legacy JSON Schema validation\n   - **Backward Compatibility**: Support existing code paths\n   - **Feature Flag**: Gradual rollout capability\n   - **Safety**: No breaking changes during transition\n\n6. WHEN all 926 existing tests are run with normalize=False THEN they SHALL pass\n   - **Requirement**: 100% pass rate (backward compatibility)\n   - **Command**: `pytest -v`\n   - **Validation**: Ensure no regressions\n\n### Requirement 4: End-to-End Testing and Validation\n\n**User Story:** As a QA engineer, I want comprehensive testing to verify Phase 2 achieves 85-87% success rate, so that we confirm the normalizer enhancement solves the identified failures.\n\n#### Acceptance Criteria\n\n1. WHEN integration tests are run with enhanced normalizer THEN success rate SHALL be ≥85%\n   - **Baseline**: Phase 1 achieved 71.4% (10/14 fixtures)\n   - **Target**: Phase 2 should reach ≥85% (12/14 fixtures)\n   - **Test Set**: Same 14 fixtures from Phase 1\n   - **Evidence**: Name normalization should fix all 4 failures\n\n2. WHEN 50-100 iterations with real LLM API are executed THEN validation success rate SHALL be ≥85%\n   - **Test Script**: `python scripts/test_yaml_validation_phase2.py --iterations 100`\n   - **Real LLM**: Use Gemini 2.5 Flash or Grok for realistic testing\n   - **Measurement**: Count successful validations / total iterations\n   - **Statistical Significance**: 100 iterations provides confidence\n\n3. WHEN tests compare before vs. after THEN improvement SHALL be measurable\n   - **Baseline (Phase 1)**: 71.4% success rate\n   - **Phase 2 (Enhanced Normalizer + Pydantic)**: ≥85% success rate\n   - **Improvement**: ≥13.6% increase\n   - **Verification**: Statistical test confirms significance\n\n4. IF success rate is <85% THEN failure analysis SHALL identify root causes\n   - **Categorize**: By error type (structural, type, semantic, pattern)\n   - **Prioritize**: Identify highest-frequency failure patterns\n   - **Document**: Feed into Phase 3 pipeline integration planning\n   - **Decision**: Determine if additional normalizer enhancements needed\n\n5. WHEN name normalization tests are run THEN all transformations SHALL work correctly\n   - **Test Cases**:\n     - Uppercase → lowercase: \"SMA_Fast\" → \"sma_fast\"\n     - Spaces → underscores: \"SMA Fast\" → \"sma_fast\"\n     - Already lowercase → unchanged: \"sma_fast\" → \"sma_fast\"\n     - Invalid names → NormalizationError\n   - **Coverage**: >90% for name normalization code\n\n6. WHEN all 926 existing tests are run THEN they SHALL pass\n   - **Command**: `pytest -v`\n   - **Requirement**: 100% pass rate with normalize=False\n   - **Safety**: Ensure backward compatibility\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n**Single Responsibility Principle:**\n- `src/generators/yaml_normalizer.py`: Data transformation (add name normalization)\n- `src/generators/pydantic_validator.py`: Pydantic validation (NEW)\n- `src/generators/yaml_schema_validator.py`: Orchestration (normalize → validate)\n- `src/models/strategy_models.py`: Pydantic models (no changes)\n\n**Modular Design:**\n- Name normalization is separate function: `_normalize_indicator_name(name: str) -> str`\n- PydanticValidator is stateless: `validate(dict) -> Tuple[bool, List[str]]`\n- Each component testable independently\n\n**Dependency Management:**\n- Normalizer: Python stdlib only (no new dependencies)\n- PydanticValidator: `pydantic` (existing dependency) + `strategy_models.py`\n- YAMLSchemaValidator: Depends on both (orchestrates)\n\n**Clear Interfaces:**\n```python\n# Enhanced Normalizer\ndef _normalize_indicator_name(name: str) -> str:\n    \"\"\"Convert indicator name to lowercase with underscores.\"\"\"\n    return name.lower().replace(' ', '_')\n\n# PydanticValidator\nclass PydanticValidator:\n    def validate(self, data: dict) -> Tuple[bool, List[str]]:\n        \"\"\"Validate against Pydantic Strategy model.\"\"\"\n        try:\n            strategy = Strategy.model_validate(data)\n            return (True, [])\n        except ValidationError as e:\n            errors = [str(err) for err in e.errors()]\n            return (False, errors)\n```\n\n### Performance\n\n**Name Normalization Speed:**\n- **Target**: <1ms per indicator (simple string operations)\n- **Impact**: Negligible (typically 3-5 indicators per strategy)\n- **Total Overhead**: <5ms per iteration\n\n**Pydantic Validation Speed:**\n- **Target**: <20ms per iteration (Pydantic is fast)\n- **Comparison**: Faster than JSON Schema validation\n- **Net Impact**: Neutral or positive (removing JSON Schema offsets Pydantic cost)\n\n**Integration Impact:**\n- **Total Validation Time**: <25ms (normalization + Pydantic)\n- **Percentage of Iteration**: <0.04% (25ms / 60000ms backtest)\n- **Acceptable**: Validation overhead is negligible\n\n### Security\n\n**Code Execution Safety:**\n- **Name Normalization**: Only string operations (no eval/exec)\n- **Pydantic Validation**: Safe validation (no code execution)\n- **Input Validation**: Pattern matching prevents injection\n\n**Data Integrity:**\n- **Immutability**: Deep copy in normalizer (input not mutated)\n- **Type Safety**: Pydantic enforces strict types\n- **Validation Chain**: Normalizer → Pydantic (two defense layers)\n\n### Reliability\n\n**Error Handling:**\n- **NormalizationError**: Clear signal for retry (Phase 3)\n- **ValidationError**: Detailed field-level errors\n- **Graceful Degradation**: Fallback to legacy validation if normalize=False\n\n**Backward Compatibility:**\n- **Feature Flag**: `normalize` parameter controls new behavior\n- **Test Coverage**: 926 tests must pass with normalize=False\n- **Migration Path**: Gradual rollout without breaking changes\n\n**Monitoring:**\n- **Success Rate Tracking**: Log normalization + validation success/failure\n- **Name Transformation Stats**: Count how often names need normalization\n- **Error Categorization**: Track error types for Phase 3 planning\n\n### Usability\n\n**Developer Experience:**\n- **Clear Error Messages**: \"indicator name 'SMA_Fast' normalized to 'sma_fast'\"\n- **Field Paths in Errors**: \"indicators.technical_indicators.0.name\"\n- **Testing**: Easy to add new test cases (use existing fixture pattern)\n\n**Integration Simplicity:**\n- **Drop-in Enhancement**: Modify existing normalizer function\n- **No Configuration**: Works automatically\n- **Optional**: Controlled by normalize parameter\n\n**Documentation:**\n- **API Docs**: Comprehensive docstrings (Google-style)\n- **Integration Guide**: Update yaml_schema_validator.py\n- **Troubleshooting**: Document name normalization logic\n\n### Maintainability\n\n**Code Quality:**\n- **Type Hints**: All functions fully typed (mypy strict)\n- **PEP 8 Compliance**: flake8 passing, 100-char line length\n- **Test Coverage**: >85% for yaml_normalizer.py, >80% for pydantic_validator.py\n\n**Configuration Management:**\n- **No Configuration**: Name normalization rules are hardcoded (simple and clear)\n- **Feature Flag**: normalize parameter in YAMLSchemaValidator\n- **Easy to Extend**: Add new transformation patterns as needed\n\n**Future-Proofing:**\n- **Plugin Architecture**: Easy to add validators (inherit from PydanticValidator)\n- **Schema Evolution**: Regenerate Pydantic models if schema changes\n- **Migration to AST**: Name normalization can be replaced without interface changes\n\n---\n\n**Document Version**: 1.0\n**Created**: 2025-10-27\n**Status**: Draft - Pending Approval\n**Owner**: Personal Project (週/月交易系統)\n**Dependencies**: Phase 1 Failure Analysis (PHASE1_FAILURE_ANALYSIS.md)\n**Estimated Effort**: 5-7 hours\n- Task 1: Enhanced Normalizer (name normalization) - 1.5h\n- Task 2: PydanticValidator Implementation - 2h\n- Task 3: YAMLSchemaValidator Integration - 1h\n- Task 4: Testing and Validation (50-100 iterations) - 1.5h\n",
  "fileStats": {
    "size": 15216,
    "lines": 334,
    "lastModified": "2025-10-27T02:20:41.842Z"
  },
  "comments": []
}