# -*- coding: utf-8 -*-
"""ETF00919_公開版.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uD2DkcugVXwHLZvHEceMG2BQWTRDRypA
"""

!pip install finlab > log.txt

from finlab import data
from finlab.backtest import sim
import finlab
from finlab.dataframe import FinlabDataFrame
import pandas as pd
import numpy as np

"""# 指數編製規則說明

## 1. 標的指數成分股的採納原則

### ① 採樣母體

- **A. 指數母體**：
  - 臺灣證券交易所上市與中華民國證券櫃檯買賣中心上櫃普通股股票。
  - 排除：管理股票、興櫃股票經公告為變更交易方法或停止買賣者。
  - 例外納入：因減資、轉換為控股公司、新設公司或變更面額等換發新股票而停止買賣者。
- **B. 採樣範圍**：指數母體中發行市值前 300 大股票。

### ② 成分股篩選標準

- **A. 流動性門檻**：
  - 日平均成交金額指標需高於 8,000 萬元。
  - 若檔數不足 150 檔，則依日平均成交金額由大至小補足至 150 檔。
- **B. 財務健全性**：近四季稅後 ROE 為正數。
- **C. 股利資訊要求（五月定審適用）**：
  - 排除董事會尚未決定現金股利金額者。
  - 排除生效日前已除息之年配息股票。

### ③ 排序方式

- **A. 五月定審**：依照「股利率」大小排序，選取前 30 檔為成分股。
- **B. 十二月定審**：依照「預估股利率」大小排序，選取前 30 檔為成分股。

### ④ 權重計算方式

- 以「股利率加權」，再依「流動量指標」調整權重。
- 單一成分股權重不得超過 10%，權重下限為 0.5%。

### ➄ 定義說明

- **A. 日平均成交金額指標**：
  - 為「近 1 個月」與「近 6 個月」之日平均成交金額，兩者取其低。
- **B. 股利率**：
  - 為近四季現金股利 ÷ （5 月審核資料截止日股價）。
- **C. 預估股利率**：
  - 為「股利率 ×（1 + 累積前三季同期每股稅後盈餘成長率）」
  - 其中「股利率」為近四季現金股利 ÷（11 月審核資料截止日股價）。
- **D. 流動量指標**：
  - 為近 6 個月日成交金額之中位數。

---

## 2. 標的指數成分股的替換原則

### ① 定期審核時間點

- 每年進行兩次定期審核：
  - **五月**：第 17 個交易日為基準日，資料截至第 10 個交易日。
  - **十二月**：第 7 個交易日為基準日，資料截至 11 月最後一個交易日。
- 每次固定選取 30 檔成分股。

### ② 成分股替換規則

- 排名在第 15 名以內者納入成分股。
- 既有成分股若跌出第 46 名，則剔除。
- 排名第 16 至 45 名者為候補名單，優先保留既有成分股。
- 十二月定審更替股票最多不得超過 8 檔。

### ③ 審核結果生效時間

- 成分股審核結果於基準日後第 5 個交易日生效。
"""

# 公開書名書修改版
# --- 輔助函數 ---
def get_trading_day_of_month(year, month, day_number, trading_dates):
    """取得某年某月第 N 個交易日"""
    month_dates = trading_dates[(trading_dates.year == year) & (trading_dates.month == month)]
    if len(month_dates) >= day_number:
        return month_dates[day_number - 1]
    return None

def get_last_trading_day_of_month(year, month, trading_dates):
    """取得某年某月最後一個交易日"""
    month_dates = trading_dates[(trading_dates.year == year) & (trading_dates.month == month)]
    if len(month_dates) > 0:
        return month_dates[-1]
    return None

def get_nearest_future_trading_date(target_date, trading_dates):
    """找到等於或在 target_date 之後的第一個交易日"""
    if target_date is None or target_date > trading_dates[-1]:
        return None
    try:
        return trading_dates[trading_dates.searchsorted(target_date)]
    except IndexError:
        return None

def get_nearest_past_trading_date(target_date, trading_dates):
    """找到等於或在 target_date 之前的最後一個交易日"""
    if target_date is None or target_date < trading_dates[0]:
        return None
    try:
        idx = trading_dates.searchsorted(target_date, side='right')
        # Handle edge case where target_date is before the first date
        if idx == 0:
            return None
        return trading_dates[idx - 1]
    except IndexError:
        return None

# --- 調倉日期計算模塊 ---
def calculate_review_dates(trading_dates: pd.DatetimeIndex):
    """
    計算台灣高股息指數的審核與調倉日期

    台灣高股息指數規則:
    - 5月: 第17個交易日為審核基準日，審核資料截至5月第10個交易日
    - 12月: 第7個交易日為審核基準日，審核資料截至11月最後交易日
    - 生效日: 審核基準日後第5個交易日
    """
    review_dates_info = []
    start_year = trading_dates[0].year
    end_year = trading_dates[-1].year

    for year in range(start_year, end_year + 1):
        # 5月定審
        may_review_basis_day = get_trading_day_of_month(year, 5, 17, trading_dates)
        may_data_cutoff_day = get_trading_day_of_month(year, 5, 10, trading_dates)

        if may_review_basis_day and may_data_cutoff_day:
            target_effective_day_index = trading_dates.searchsorted(may_review_basis_day) + 5
            if target_effective_day_index < len(trading_dates):
                may_effective_day_target = trading_dates[target_effective_day_index]
                may_effective_day = get_nearest_future_trading_date(may_effective_day_target, trading_dates)
                if may_effective_day:
                    review_dates_info.append({
                        'year': year,
                        'month': 5,
                        'cutoff_date': may_data_cutoff_day,
                        'basis_date': may_review_basis_day,
                        'effective_date': may_effective_day
                    })

        # 12月定審
        dec_review_basis_day = get_trading_day_of_month(year, 12, 7, trading_dates)
        nov_data_cutoff_day = get_last_trading_day_of_month(year, 11, trading_dates)

        if dec_review_basis_day and nov_data_cutoff_day:
            target_effective_day_index = trading_dates.searchsorted(dec_review_basis_day) + 5
            if target_effective_day_index < len(trading_dates):
                dec_effective_day_target = trading_dates[target_effective_day_index]
                dec_effective_day = get_nearest_future_trading_date(dec_effective_day_target, trading_dates)
                if dec_effective_day:
                    review_dates_info.append({
                        'year': year,
                        'month': 12,
                        'cutoff_date': nov_data_cutoff_day,
                        'basis_date': dec_review_basis_day,
                        'effective_date': dec_effective_day
                    })

    # 按生效日期排序
    review_dates_info = sorted(review_dates_info, key=lambda x: x['effective_date'])
    # 移除無效日期
    review_dates_info = [info for info in review_dates_info if info['effective_date'] is not None]

    if not review_dates_info:
        raise ValueError("無法計算出任何有效的審核與生效日期，請檢查日期計算邏輯或資料範圍。")

    return review_dates_info

print("計算審核與生效日期...")
close_all = data.get('price:收盤價')['2022-10-20':]
all_trading_dates = pd.to_datetime(close_all.index)

review_dates_info = calculate_review_dates(all_trading_dates)
basis_dates = pd.DatetimeIndex([info['basis_date'] for info in review_dates_info])
effective_dates = pd.DatetimeIndex([info['effective_date'] for info in review_dates_info])
# 上市與上櫃股票為母體

close_all = data.get('price:收盤價')
with data.universe(market='TSE_OTC'):
    市值 = data.get('etl:market_value')
    close = data.get('price:收盤價')['2022-10-20':]
    volume = data.get('price:成交股數')
    trans_amount = data.get('price:成交金額')

    # 計算現金股利
    def 計算盈餘分配現金股利():
        df = data.get('board_dividend_announcement')
        dates = df['股東會日期'].fillna(df['董事會決議（擬議）股利分派日'])

        cash_dividend = FinlabDataFrame(data.get('board_dividend_announcement')\
        .drop_duplicates(['stock_id', '股東配發之現金(股利)總金額(元)'], keep='first')\
        .groupby([df.stock_id, dates])\
        .first()['盈餘分配之現金股利(元/股)']\
        .dropna().reset_index()\
        .pivot(index='股東會日期', columns='stock_id', values='盈餘分配之現金股利(元/股)'))\
        .rename_axis('date').rename_axis('symbol', axis=1)
        return cash_dividend

    def 計算董事決定分配現金股利():
        df = data.get('board_dividend_announcement')
        dates = df['股東會日期'].fillna(df['董事會決議（擬議）股利分派日'])
        board_cash_dividend = FinlabDataFrame(data.get('board_dividend_announcement')\
        .drop_duplicates(['stock_id', '股東配發之現金(股利)總金額(元)'], keep='first')\
        .groupby([df.stock_id, dates])\
        .first()['盈餘分配之現金股利(元/股)']\
        .dropna().reset_index()\
        .pivot(index='股東會日期', columns='stock_id', values='盈餘分配之現金股利(元/股)'))\
        .rename_axis('date').rename_axis('symbol', axis=1)
        return board_cash_dividend

    # 採樣母體
    # 市值前 300 大股票
    市值條件 = 市值.is_largest(300)

    # 成分股篩選標準
    # 日平均成交金額指標為近 1 個月與近 6 個月之日平均成交金額，兩者取其低。
    # 日平均成交金額指標高於 8,000 萬元；若檔數不足 150 檔
    turnover_1m = trans_amount.rolling(22).mean()
    turnover_6m = trans_amount.rolling(120).mean()
    # 兩者取較小值
    turnover_min = pd.DataFrame(np.minimum(turnover_1m, turnover_6m),
                                index=trans_amount.index,
                                columns=trans_amount.columns)
    流動性條件 = (turnover_min >= 80_000_000)

    # 近四季稅後 ROE 為正數
    ROE = data.get('fundamental_features:ROE稅後')
    roe_mean = ROE.rolling(4).mean()  # 計算近四季平均 ROE
    roe_min = ROE.rolling(4).min()  # 計算近四季 ROE
    獲利條件 = (roe_mean > 0) & (roe_min > 0)  # 近四季 ROE 均為正值


    基本條件 = close > 0
    # 選股條件整合
    conds = (
        基本條件
        & 市值條件
        & 流動性條件
        & 獲利條件
    )

    # - **B. 股利率**：
    # - 為近四季現金股利 ÷ （5 月審核資料截止日股價）。
    board_cash_dividend = FinlabDataFrame(計算董事決定分配現金股利()).ffill().fillna(0)
    cash_dividend = FinlabDataFrame(計算盈餘分配現金股利()).ffill().fillna(0)
    近四季現金股利總和 = FinlabDataFrame((cash_dividend).rolling(252, min_periods=1).sum())
    股利率 = (近四季現金股利總和 / close)

    # - **C. 預估股利率**：
    # - 為「股利率 ×（1 + 累積前三季同期每股稅後盈餘成長率）」
    EPS = data.get('fundamental_features:每股稅後淨利')
    # 計算累積前三季 EPS（例如 Q1~Q3、Q2~Q4）
    eps_3q_sum_current = EPS.fillna(0).rolling(window=3).sum()
    # 取得去年同期前三季 EPS（向前平移 4 季）
    eps_3q_sum_last_year = eps_3q_sum_current.shift(4)
    # 計算 EPS 年增率（Year-over-Year），若無法計算（如除以0）則補0
    eps_3q_yoy_growth = ((eps_3q_sum_current / eps_3q_sum_last_year.replace(0, np.nan)).replace([np.inf, -np.inf], np.nan) - 1).fillna(0)
    # eps成長因子，最小為0，避免負成長造成錯誤
    eps_growth_multiplier = (1 + eps_3q_yoy_growth).clip(lower=0)
    # - 其中「股利率」為近四季現金股利 ÷（11 月審核資料截止日股價）。
    預估股利率 = (股利率 * eps_growth_multiplier).fillna(0)

    yield_ratio = data.get('price_earning_ratio:殖利率(%)')

# 建立 position DataFrame
def calculate_ranks(date, is_may_review=True):
    """計算特定審核日期的股票排名"""
    nearest_date = get_nearest_past_trading_date(date, all_trading_dates)
    if nearest_date is None:
        return pd.Series(dtype=float)  # 空序列

    if is_may_review:  # 5月定審
        # 計算排名 - 5月定審使用股利率
        score = (市值.rank(axis=1, pct=True) + 股利率.rank(axis=1, pct=True) + yield_ratio.rank(axis=1, pct=True))[conds & (board_cash_dividend > 0)]
    else:  # 12月定審
        # 計算排名 - 12月定審使用預估股利率
        score = (市值.rank(axis=1, pct=True) + 預估股利率.rank(axis=1, pct=True) + yield_ratio.rank(axis=1, pct=True))[conds]

    if nearest_date not in score.index:
        return pd.Series(dtype=float)  # 空序列

    return score.loc[nearest_date].dropna().rank(ascending=False, method='min')

# 2. 建立空的結果DataFrame
position = pd.DataFrame(False, index=effective_dates, columns=close.columns)

# 3. 處理所有調倉日期和排名數據
all_ranks = {}
valid_dates = []

for date in effective_dates:
    try:
        is_may_review = (date.month == 5)
        ranks = calculate_ranks(date, is_may_review)
        if not ranks.empty:
            all_ranks[date] = ranks
            valid_dates.append(date)
    except Exception as e:
        print(f"處理 {date} 時發生錯誤: {e}")

valid_dates = sorted(valid_dates)  # 確保日期順序

if not valid_dates:
    print("沒有有效的調倉日期，無法進行模擬")
else:
		# 4. 使用 Pandas 向量化處理成分股替換
    prev_components = None
    target_component_count = 30 # 設定目標成分股數量

    for i, date in enumerate(valid_dates):
                ranks = all_ranks[date]

                # 1. 排名在第15名以內者納入成分股
                top_15 = set(ranks[ranks <= 15].index)

                # 2. 排名16至45名為候補名單
                candidates = set(ranks[(ranks > 15) & (ranks <= 45)].index)

                # 暫定的成分股 (先加入前15名)
                current_components_tentative = set(top_15)

                # 如果不是第一次調倉
                if prev_components is not None:
                        # 加入排名16-45之間的既有成分股
                        existing_in_candidates = prev_components.intersection(candidates)
                        current_components_tentative.update(existing_in_candidates)

                        # 對於12月定審，額外限制最多替換8檔
                        if date.month == 12:
                                # 計算基於 Top15 + 既有候補 所得的新增股票
                                added = current_components_tentative - prev_components

                                # 如果新增超過8檔，需要減少替換數量
                                if len(added) > 8:
                                        # 取出新增的股票並按排名排序 (rank越小越好)
                                        added_with_rank = pd.Series({stock: ranks.get(stock, float('inf')) for stock in added})
                                        # 只保留排名最好的前8名新增的股票
                                        to_keep = set(added_with_rank.sort_values().index[:8])
                                        to_remove_due_to_limit = added - to_keep

                                        # 從暫定名單中移除因超過8檔限制而被剔除的股票
                                        current_components_tentative = current_components_tentative - to_remove_due_to_limit

                # --- 新增：補滿至目標數量 ---
                num_needed = target_component_count - len(current_components_tentative)
                if num_needed > 0:
                        # 找出所有排名16-45，但尚未被選入的股票
                        remaining_candidates = candidates - current_components_tentative
                        if remaining_candidates: # 確保還有候選股可補
                                # 依排名排序這些候選股
                                remaining_candidates_with_rank = pd.Series({stock: ranks.get(stock, float('inf')) for stock in remaining_candidates})
                                sorted_remaining_candidates = remaining_candidates_with_rank.sort_values().index

                                # 選取排名最好的 num_needed 檔來補滿
                                stocks_to_add = set(sorted_remaining_candidates[:num_needed])
                                current_components_tentative.update(stocks_to_add)
                # --- 補滿邏輯結束 ---

                # 最終確認的成分股
                current_components = current_components_tentative

                # 設定成分股
                # 確保只設定存在的欄位
                valid_cols = [col for col in current_components if col in position.columns]
                position.loc[date, valid_cols] = True

                # 更新前一期成分股
                prev_components = current_components

                print(f"成功處理 {date}，選出 {len(current_components)} 檔成分股")
    # 5. 前向填充空值，確保非調倉日也有持股
    position = position.loc[valid_dates]

    # 6. 執行回測
    # report = sim(position.loc[valid_dates[0]:], resample=valid_dates, upload=False, position_limit=0.1)
    report = sim(position.loc['2022-12-27':], resample=effective_dates, upload=False, position_limit=0.1)
    report.display()

import pandas as pd
from finlab.dataframe import FinlabDataFrame
# 檢查與實際 00919 成分股的重疊度
current_00919_stocks = pd.Series([
    '2603',  # 長榮
    '2303',  # 聯電
    '2891',  # 中信金
    '2454',  # 聯發科
    '3034',  # 聯詠
    '2618',  # 長榮航
    '5347',  # 世界
    '8299',  # 群聯
    '6239',  # 力成
    '6176',  # 瑞儀
    '6121',  # 新普
    '2606',  # 裕民
    '6005',  # 群益證
    '2809',  # 京城銀
    '5522',  # 遠雄
    '2637',  # 慧洋-KY
    '5904',  # 寶雅
    '2504',  # 國產
    '2889',  # 國票金
    '2404',  # 漢唐
    '2451',  # 創見
    '4915',  # 致伸
    '2393',  # 億光
    '6691',  # 洋基工程
    '6278',  # 台表科
    '5508',  # 永信建
    '1442',  # 名軒
    '8112',  # 至上
    '3592',  # 瑞鼎
    '2348',  # 海悅
]).astype(str)

# 買進持有 00919
long_position = ~close_all[['00919']].isna().loc['2022-12-27':]
report_00919 = sim(long_position, upload=False)

report_00919.display()

def calculate_overlap_ratio(p, current_0056_stocks):
    our_stocks = p[p].index
    overlap_stocks = our_stocks.intersection(current_0056_stocks)
    overlap_ratio = len(overlap_stocks) / len(current_0056_stocks)
    print(f'重疊股票數: {len(overlap_stocks)}')
    print(f'重疊比例: {overlap_ratio:.2%}')

    missing_stocks = set(current_0056_stocks) - set(our_stocks)
    print("\n未選中的成分股:")
    print(sorted(list(missing_stocks)))

    extra_stocks = set(our_stocks) - set(current_0056_stocks)
    print("\n多選中的成分股:")
    print(sorted(list(extra_stocks)))

    return overlap_ratio , missing_stocks, extra_stocks

def analyze_correlations(series1, series2, name1="Series 1", name2="Series 2"):
    """
    全面分析兩個時間序列的相關性

    Parameters:
    -----------
    series1, series2 : pandas.Series
        要分析的兩個時間序列
    name1, name2 : str
        兩個時間序列的名稱，用於顯示結果

    Returns:
    --------
    dict
        包含各種相關性分析結果的字典
    """
    results = {}

    # 1. 對齊數據確保兩個時間序列有相同的索引
    s1_aligned, s2_aligned = series1.align(series2, join='inner')

    # 檢查是否有足夠的數據點
    if len(s1_aligned) <= 1:
        return {"error": "數據點不足，無法計算相關性"}

    # 2. 計算不同類型的相關係數
    results["pearson"] = s1_aligned.corr(s2_aligned, method='pearson')
    results["spearman"] = s1_aligned.corr(s2_aligned, method='spearman')
    results["kendall"] = s1_aligned.corr(s2_aligned, method='kendall')

    # 3. 按年計算相關性
    yearly_corr = {}
    y_start = s1_aligned.index[0].year
    y_end = s1_aligned.index[-1].year

    for y in range(y_start, y_end+1):
        mask = s1_aligned.index.year == y
        s1_year = s1_aligned[mask]
        s2_year = s2_aligned[mask]

        if len(s1_year) > 1:
            yearly_corr[y] = s1_year.corr(s2_year)
        else:
            yearly_corr[y] = None

    results["yearly_correlation"] = yearly_corr

    # 4. 計算滾動相關性
    results["rolling_corr_30d"] = s1_aligned.rolling(window=30).corr(s2_aligned)
    results["rolling_corr_90d"] = s1_aligned.rolling(window=90).corr(s2_aligned)

    return results

def print_correlation_report(results, name1="Series 1", name2="Series 2"):
    """
    格式化顯示相關性分析結果

    Parameters:
    -----------
    results : dict
        analyze_correlations 函數返回的結果字典
    name1, name2 : str
        兩個時間序列的名稱
    """
    if "error" in results:
        print(f"錯誤: {results['error']}")
        return

    print(f"\n===== {name1} 與 {name2} 相關性分析 =====")
    print(f"皮爾森相關係數: {results['pearson']:.4f}")
    print(f"斯皮爾曼等級相關係數: {results['spearman']:.4f}")
    print(f"肯德爾陶相關係數: {results['kendall']:.4f}")

    print("\n每年相關性:")
    for year, corr in results["yearly_correlation"].items():
        if corr is not None:
            print(f"{year}年: {corr:.4f}")
        else:
            print(f"{year}年: 數據不足")

    print("\n滾動相關性統計:")
    print("30天滾動窗口:")
    print(results["rolling_corr_30d"].describe())
    print("\n90天滾動窗口:")
    print(results["rolling_corr_90d"].describe())

# 檢查重疊度
overlap_ratio , missing_stocks, extra_stocks = calculate_overlap_ratio(position.loc['2024-12-17'].fillna(False), current_00919_stocks)

results = analyze_correlations(report.creturn,report_00919.creturn, '復刻00919', '原始00919')
print_correlation_report(results, '復刻00919', '原始00919')

# 分析條件
from finlab.tools.factor_analysis import ic

獲利條件 = (roe_mean.index_str_to_date() > 0)
rev = data.get('monthly_revenue:當月營收')
營收成長_3 = (rev > rev.average(3))
營收成長_12 = (rev > rev.average(12))

std = close.pct_change().rolling(60).std().rank(axis=1, pct=True)
波動條件 = (std < 0.9)
均線條件_20 = (close>close.average(20))
均線條件_120 = (close>close.average(120))
均線條件_240 = (close>close.average(240))
yield_ratio = data.get('price_earning_ratio:殖利率(%)')
殖利率條件 = (yield_ratio >= yield_ratio.quantile(0.6, axis=1))

factors = {
  '市值條件':      市值條件,
  '流動性條件':    流動性條件,
  '獲利條件':      獲利條件,
  '波動條件':      波動條件,
  '均線條件':      均線條件_20,
  '殖利率條件':     殖利率條件,
}

# 取得調整後收盤價
adj_close = data.get('etl:adj_close')

# 定義股票池條件
stock_condition = conds

# 計算特定股票池內的因子效果
ics = ic(factors, adj_close, days=[60, 120])

# 計算 IC IR
ic_mean = ics.mean(axis=0)
ic_std  = ics.std(axis=0)
ic_ir   = ic_mean / ic_std

# 組成結果表並排序
result = pd.DataFrame({
    'IC Mean': ic_mean,
    'IC Std' : ic_std,
    'IC IR'  : ic_ir
})
result = result.sort_values('IC IR', ascending=False)

print(result)

"""# 優化版"""

import pandas as pd
close_all = data.get('price:收盤價')
with data.universe(market='TSE_OTC'):
    市值 = data.get('etl:market_value')
    close = data.get('price:收盤價')['2022-10-20':]
    volume = data.get('price:成交股數')
    trans_amount = data.get('price:成交金額')
    # 採樣母體
    # 市值前 300 大股票
    市值條件 = 市值.is_largest(300)

    # 成分股篩選標準
    # 日平均成交金額指標為近 1 個月與近 6 個月之日平均成交金額，兩者取其低。
    # 日平均成交金額指標高於 8,000 萬元；若檔數不足 150 檔
    turnover_1m = trans_amount.rolling(22).mean()
    turnover_6m = trans_amount.rolling(120).mean()
    # 兩者取較小值
    turnover_min = pd.DataFrame(np.minimum(turnover_1m, turnover_6m),
                                index=trans_amount.index,
                                columns=trans_amount.columns)
    流動性條件 = (turnover_min >= 80_000_000)

    # 近四季稅後 ROE 為正數
    ROE = data.get('fundamental_features:ROE稅後')
    roe_mean = ROE.rolling(4).mean()  # 計算近四季平均 ROE
    roe_min = ROE.rolling(4).min()  # 計算近四季 ROE
    獲利條件 = (roe_mean > 0) & (roe_min > 0)  # 近四季 ROE 均為正值
    均線條件 = (close>close.average(20))

    基本條件 = close > 0
    # 選股條件整合
    conds = (
        基本條件
        & 均線條件
        & 獲利條件
    )

    # - **B. 股利率**：
    # - 為近四季現金股利 ÷ （5 月審核資料截止日股價）。
    board_cash_dividend = FinlabDataFrame(計算董事決定分配現金股利()).ffill().fillna(0)
    cash_dividend = FinlabDataFrame(計算盈餘分配現金股利()).ffill().fillna(0)
    近四季現金股利總和 = FinlabDataFrame((cash_dividend).rolling(252, min_periods=1).sum())
    股利率 = (近四季現金股利總和 / close)

    # - **C. 預估股利率**：
    # - 為「股利率 ×（1 + 累積前三季同期每股稅後盈餘成長率）」
    EPS = data.get('fundamental_features:每股稅後淨利')
    # 計算累積前三季 EPS（例如 Q1~Q3、Q2~Q4）
    eps_3q_sum_current = EPS.fillna(0).rolling(window=3).sum()
    # 取得去年同期前三季 EPS（向前平移 4 季）
    eps_3q_sum_last_year = eps_3q_sum_current.shift(4)
    # 計算 EPS 年增率（Year-over-Year），若無法計算（如除以0）則補0
    eps_3q_yoy_growth = ((eps_3q_sum_current / eps_3q_sum_last_year.replace(0, np.nan)).replace([np.inf, -np.inf], np.nan) - 1).fillna(0)
    # eps成長因子，最小為0，避免負成長造成錯誤
    eps_growth_multiplier = (1 + eps_3q_yoy_growth).clip(lower=0)
    # - 其中「股利率」為近四季現金股利 ÷（11 月審核資料截止日股價）。
    預估股利率 = (股利率 * eps_growth_multiplier).fillna(0)

    yield_ratio = data.get('price_earning_ratio:殖利率(%)')

    cash_dividend_annual = FinlabDataFrame((cash_dividend / close).rolling(520, min_periods=1).sum())

# 2. 建立空的結果DataFrame
result = (市值.rank(axis=1, pct=True)+ 股利率.rank(axis=1, pct=True) + cash_dividend_annual.rank(axis=1, pct=True) + ROE.rank(axis=1, pct=True))[conds & (board_cash_dividend > 0)]
五月條件 = result[result > 0].is_largest(10)

# 十二月定審**：依照「預估股利率」大小排序，選取前 30 檔為成分股。
result = (市值.rank(axis=1, pct=True)+ 預估股利率.rank(axis=1, pct=True) + cash_dividend_annual.rank(axis=1, pct=True) + ROE.rank(axis=1, pct=True))[conds]
十二月條件 = result[result > 0].is_largest(10)

    # 建立 position DataFrame
position = pd.DataFrame(False, index=effective_dates, columns=close.columns)

    # # 在調倉日填入對應的選股結果
for date in effective_dates:
        if date.month == 5:  # 5月使用實際股利率
            position.loc[date] = 五月條件.reindex(index=[date], method='ffill').iloc[0].fillna(False).astype(bool)
        elif date.month == 12:  # 12月使用預估股利率
            position.loc[date] = 十二月條件.reindex(index=[date], method='ffill').iloc[0].fillna(False).astype(bool)
# 6. 執行回測
report2 = sim(position.loc['2022-12-27':], resample=effective_dates, upload=False, position_limit=0.1)
report2.display()

report.creturn.plot()
report2.creturn.plot()
report_00919.creturn.plot()