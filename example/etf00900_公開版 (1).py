# -*- coding: utf-8 -*-
"""ETF00900_公開版.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rw86fwPLxq-nAPN-YCHABDpRaJ7lXCJU
"""

!pip install finlab > log.txt

from finlab import data
from finlab.backtest import sim
import finlab
from finlab.dataframe import FinlabDataFrame
import pandas as pd
import numpy as np

import pandas as pd
# --- 輔助函數 ---
def get_trading_day_of_month(year, month, day_number, trading_dates):
    """取得某年某月第 N 個交易日"""
    month_dates = trading_dates[(trading_dates.year == year) & (trading_dates.month == month)]
    if len(month_dates) >= day_number:
        return month_dates[day_number - 1]
    return None

def get_last_trading_day_of_month(year, month, trading_dates):
    """取得某年某月最後一個交易日"""
    month_dates = trading_dates[(trading_dates.year == year) & (trading_dates.month == month)]
    if len(month_dates) > 0:
        return month_dates[-1]
    return None

def get_nearest_future_trading_date(target_date, trading_dates):
    """找到等於或在 target_date 之後的第一個交易日"""
    if target_date is None or target_date > trading_dates[-1]:
        return None
    try:
        return trading_dates[trading_dates.searchsorted(target_date)]
    except IndexError:
        return None

def get_nearest_past_trading_date(target_date, trading_dates):
    """找到等於或在 target_date 之前的最後一個交易日"""
    if target_date is None or target_date < trading_dates[0]:
        return None
    try:
        idx = trading_dates.searchsorted(target_date, side='right')
        # Handle edge case where target_date is before the first date
        if idx == 0:
            return None
        return trading_dates[idx - 1]
    except IndexError:
        return None

# --- 調倉日期計算模塊 ---
def calculate_review_dates(trading_dates: pd.DatetimeIndex):
    """
    計算台灣高股息 30 指數的審核與調倉日期

    台灣高股息 30 指數規則:
    - 4月: 第7個交易日為審核基準日，審核資料截至3月最後交易日
    - 7月: 第7個交易日為審核基準日，審核資料截至6月最後交易日
    - 12月: 第7個交易日為審核基準日，審核資料截至11月最後交易日
    - 生效日: 審核基準日後第5個交易日
    """
    review_dates_info = []
    start_year = trading_dates[0].year
    end_year = trading_dates[-1].year

    for year in range(start_year, end_year + 1):
        # 4月定審
        apr_review_basis_day = get_trading_day_of_month(year, 4, 7, trading_dates)
        mar_data_cutoff_day = get_last_trading_day_of_month(year, 3, trading_dates)

        if apr_review_basis_day and mar_data_cutoff_day:
            target_effective_day_index = trading_dates.searchsorted(apr_review_basis_day) + 5
            if target_effective_day_index < len(trading_dates):
                apr_effective_day_target = trading_dates[target_effective_day_index]
                apr_effective_day = get_nearest_future_trading_date(apr_effective_day_target, trading_dates)
                if apr_effective_day:
                    review_dates_info.append({
                        'year': year,
                        'month': 4,
                        'cutoff_date': mar_data_cutoff_day,
                        'basis_date': apr_review_basis_day,
                        'effective_date': apr_effective_day
                    })

        # 7月定審
        jul_review_basis_day = get_trading_day_of_month(year, 7, 7, trading_dates)
        jun_data_cutoff_day = get_last_trading_day_of_month(year, 6, trading_dates)

        if jul_review_basis_day and jun_data_cutoff_day:
            target_effective_day_index = trading_dates.searchsorted(jul_review_basis_day) + 5
            if target_effective_day_index < len(trading_dates):
                jul_effective_day_target = trading_dates[target_effective_day_index]
                jul_effective_day = get_nearest_future_trading_date(jul_effective_day_target, trading_dates)
                if jul_effective_day:
                    review_dates_info.append({
                        'year': year,
                        'month': 7,
                        'cutoff_date': jun_data_cutoff_day,
                        'basis_date': jul_review_basis_day,
                        'effective_date': jul_effective_day
                    })

        # 12月定審
        dec_review_basis_day = get_trading_day_of_month(year, 12, 7, trading_dates)
        nov_data_cutoff_day = get_last_trading_day_of_month(year, 11, trading_dates)

        if dec_review_basis_day and nov_data_cutoff_day:
            target_effective_day_index = trading_dates.searchsorted(dec_review_basis_day) + 5
            if target_effective_day_index < len(trading_dates):
                dec_effective_day_target = trading_dates[target_effective_day_index]
                dec_effective_day = get_nearest_future_trading_date(dec_effective_day_target, trading_dates)
                if dec_effective_day:
                    review_dates_info.append({
                        'year': year,
                        'month': 12,
                        'cutoff_date': nov_data_cutoff_day,
                        'basis_date': dec_review_basis_day,
                        'effective_date': dec_effective_day
                    })

    # 按生效日期排序
    review_dates_info = sorted(review_dates_info, key=lambda x: x['effective_date'])
    # 移除無效日期
    review_dates_info = [info for info in review_dates_info if info['effective_date'] is not None]

    if not review_dates_info:
        raise ValueError("無法計算出任何有效的審核與生效日期，請檢查日期計算邏輯或資料範圍。")

    return review_dates_info

print("計算審核與生效日期...")
close_all = data.get('price:收盤價')['2021-12-22':]
all_trading_dates = pd.to_datetime(close_all.index)

review_dates_info = calculate_review_dates(all_trading_dates)
basis_dates = pd.DatetimeIndex([info['basis_date'] for info in review_dates_info])
effective_dates = pd.DatetimeIndex([info['effective_date'] for info in review_dates_info])
# 上市與上櫃股票為母體

def fill_dividend_to_adjust_day(cash_dividend, adjust_dates, direction='forward'):
    """
    將股利資料填入特定期間內的調整日期。
    """
    if not isinstance(cash_dividend, pd.DataFrame):
        raise TypeError("cash_dividend must be a pandas DataFrame.")
    if not pd.api.types.is_datetime64_any_dtype(cash_dividend.index):
        try:
            cash_dividend.index = pd.to_datetime(cash_dividend.index)
        except Exception as e:
            raise TypeError(f"cash_dividend.index must be a DatetimeIndex or convertible to datetime. Error: {e}")

    try:
        adjust_dates_dt = pd.to_datetime(adjust_dates)
    except Exception as e:
        raise TypeError(f"adjust_dates must be convertible to datetime. Error: {e}")

    if cash_dividend.empty or len(adjust_dates_dt) == 0:
        # Return empty DataFrame with correct structure if inputs are empty
        return FinlabDataFrame(index=adjust_dates_dt, columns=cash_dividend.columns)

    # 建立調整日期區間結束點
    period_ends = pd.Series(adjust_dates_dt).shift(-1)
    period_ends.iloc[-1] = pd.Timestamp.max

    # 將 cash_dividend 轉為長格式 (Long format)
    dividend_long = cash_dividend.stack(dropna=True).reset_index()
    dividend_long.columns = ['div_date', 'stock', 'dividend']

    # 確保欄位類型正確 (Ensure correct data types)
    dividend_long['stock'] = dividend_long['stock'].astype(str)

    # 建立調整日與股票的交叉資料表
    adj_dates_df = pd.DataFrame(
        [(d, s) for d in adjust_dates_dt for s in cash_dividend.columns],
        columns=['adj_date', 'stock']
    )
    # Ensure correct data types
    adj_dates_df['stock'] = adj_dates_df['stock'].astype(str)

    # 建立從調整日到區間結束點的映射
    adj_date_to_period_end = pd.Series(period_ends.values, index=adjust_dates_dt)
    adj_dates_df['period_end'] = adj_dates_df['adj_date'].map(adj_date_to_period_end)

    # 使用 merge_asof 進行時間點匹配
    merged = pd.merge_asof(
        adj_dates_df.sort_values('adj_date'),
        dividend_long.sort_values('div_date'),
        left_on='adj_date',
        right_on='div_date',
        by='stock',
        direction=direction
    )

    # 篩選: 保留除息日落在調整期間內的股利值
    merged['dividend'] = np.where(
        (merged['div_date'].notna()) & (merged['div_date'] < merged['period_end']),
        merged['dividend'],
        np.nan
    )

    # 重整回寬格式 (Pivot back to wide format)
    result = merged.pivot(index='adj_date', columns='stock', values='dividend')

    # 確保所有原始股票ID都存在於結果中，即使它們沒有任何匹配的股利
    result = result.reindex(columns=cash_dividend.columns)
    # 確保所有原始調整日期都存在於結果中
    result = result.reindex(index=adjust_dates_dt)

    return FinlabDataFrame(result)

close_all = data.get('price:收盤價')
with data.universe(market='TSE_OTC'):
    市值 = data.get('etl:market_value')
    close = data.get('price:收盤價')['2021-12-22':]
    volume = data.get('price:成交股數')
    trans_amount = data.get('price:成交金額')

    # 計算現金股利
    def 計算盈餘分配現金股利():
        df = data.get('dividend_announcement')
        dates = df['除息交易日']

        cash_dividend = FinlabDataFrame(data.get('dividend_announcement')\
        .drop_duplicates(['stock_id', '盈餘分配之股東現金股利(元/股)'], keep='first')\
        .groupby([df.stock_id, dates])\
        .first()['盈餘分配之股東現金股利(元/股)']\
        .dropna().reset_index()\
        .pivot(index='除息交易日', columns='stock_id', values='盈餘分配之股東現金股利(元/股)')\
        )
        return cash_dividend

    def 計算董事決定分配現金股利():
        df = data.get('board_dividend_announcement')
        dates = df['股東會日期'].fillna(df['董事會決議（擬議）股利分派日'])
        board_cash_dividend = FinlabDataFrame(data.get('board_dividend_announcement')\
        .drop_duplicates(['stock_id', '股東配發之現金(股利)總金額(元)'], keep='first')\
        .groupby([df.stock_id, dates])\
        .first()['盈餘分配之現金股利(元/股)']\
        .dropna().reset_index()\
        .pivot(index='股東會日期', columns='stock_id', values='盈餘分配之現金股利(元/股)'))\
        .rename_axis('date').rename_axis('symbol', axis=1)
        return board_cash_dividend

    # 採樣母體
    # 市值前 200 大股票
    市值條件 = 市值.is_largest(200)

    # 成分股篩選標準
    # 最近三個月日均成交金額前 90% 股票納入合格名單
    turnover_3m = trans_amount.rolling(60).mean()  # 約3個月
    流動性條件 = turnover_3m.rank(axis=1, pct=True) >= 0.1  # 取前 90%

    # 近四季營業利益總和為正
    營業利益 = data.get('fundamental_features:營業利益')
    營業利益_4Q = 營業利益.rolling(4).sum()  # 計算近四季營業利益總和
    獲利條件 = (營業利益_4Q > 0)  # 近四季營業利益總和為正

    基本條件 = close > 0
    # 選股條件整合
    conds = (
        基本條件
        & 市值條件
        & 流動性條件
        & 獲利條件
    )


    board_cash_dividend = FinlabDataFrame(計算董事決定分配現金股利())#.ffill().fillna(0)
    cash_dividend = FinlabDataFrame(計算盈餘分配現金股利())#.ffill().fillna(0)
    近四季現金股利總和 = cash_dividend.ffill().fillna(0).resample('Q').last().rolling(4).sum()
    yield_ratio = data.get('price_earning_ratio:殖利率(%)')

    # 計算各期股利率
    filled_board_cash_dividend = fill_dividend_to_adjust_day(board_cash_dividend, effective_dates, direction='backward')
    filled_cash_dividend = fill_dividend_to_adjust_day(cash_dividend, effective_dates, direction='forward')

    # 四月股利率計算
    已公告股利 = (filled_board_cash_dividend.reindex(index=close.index) > 0)
    股利率 = (近四季現金股利總和 / close)
    未公告股利 = ~已公告股利
    EPS = data.get('fundamental_features:每股稅後淨利')
    最近四季_EPS_總和 = EPS.rolling(4).sum()
    現金股利發放率 = cash_dividend.ffill().fillna(0).resample('Q').last() / EPS
    過去三年平均現金股利發放率 = 現金股利發放率.resample('D').last().ffill().fillna(0).rolling(720, min_periods=1).mean()

    undeclared_yield = (最近四季_EPS_總和 * 過去三年平均現金股利發放率)/close
    四月股利率 = 已公告股利 * 股利率 + 未公告股利 * undeclared_yield
    四月條件 = ((四月股利率.rank(axis=1, pct=True))* conds).is_largest(30)

    # 七月股利率計算
    七月股利率 = (近四季現金股利總和 / close)
    七月條件 = ((七月股利率.rank(axis=1, pct=True))* conds).is_largest(30)


    # 十二月股利率計算
    十二月股利率 = (最近四季_EPS_總和 * 過去三年平均現金股利發放率)/close
    十二月條件 = ((十二月股利率.rank(axis=1, pct=True))* conds).is_largest(30)


# 建立 position DataFrame
position = pd.DataFrame(False, index=effective_dates, columns=close.columns)

# 在調倉日填入對應的選股結果
for date in effective_dates:

    # 根據不同定審時間使用不同選股邏輯
    if date.month == 4:  # 第一次定期審核
        position.loc[date] = 四月條件.reindex(index=[date], method='ffill').iloc[0].fillna(False).astype(bool)

    elif date.month == 7:  # 第二次定期審核
        position.loc[date] = 七月條件.reindex(index=[date], method='ffill').iloc[0].fillna(False).astype(bool)

    elif date.month == 12:  # 第三次定期審核
        position.loc[date] = 十二月條件.reindex(index=[date], method='ffill').iloc[0].fillna(False).astype(bool)

report = sim(position.loc['2021-12-22':], resample=effective_dates, upload=False)
report.display()

# 買進持有 00900 ETF
long_position = ~close_all[['00900']].isna().loc['2021-12-22':]
report_00900 = sim(long_position, upload=False)

def analyze_correlations(series1, series2, name1="Series 1", name2="Series 2"):
    """
    全面分析兩個時間序列的相關性

    Parameters:
    -----------
    series1, series2 : pandas.Series
        要分析的兩個時間序列
    name1, name2 : str
        兩個時間序列的名稱，用於顯示結果

    Returns:
    --------
    dict
        包含各種相關性分析結果的字典
    """
    results = {}

    # 1. 對齊數據確保兩個時間序列有相同的索引
    s1_aligned, s2_aligned = series1.align(series2, join='inner')

    # 檢查是否有足夠的數據點
    if len(s1_aligned) <= 1:
        return {"error": "數據點不足，無法計算相關性"}

    # 2. 計算不同類型的相關係數
    results["pearson"] = s1_aligned.corr(s2_aligned, method='pearson')
    results["spearman"] = s1_aligned.corr(s2_aligned, method='spearman')
    results["kendall"] = s1_aligned.corr(s2_aligned, method='kendall')

    # 3. 按年計算相關性
    yearly_corr = {}
    y_start = s1_aligned.index[0].year
    y_end = s1_aligned.index[-1].year

    for y in range(y_start, y_end+1):
        mask = s1_aligned.index.year == y
        s1_year = s1_aligned[mask]
        s2_year = s2_aligned[mask]

        if len(s1_year) > 1:
            yearly_corr[y] = s1_year.corr(s2_year)
        else:
            yearly_corr[y] = None

    results["yearly_correlation"] = yearly_corr

    # 4. 計算滾動相關性
    results["rolling_corr_30d"] = s1_aligned.rolling(window=30).corr(s2_aligned)
    results["rolling_corr_90d"] = s1_aligned.rolling(window=90).corr(s2_aligned)

    return results

def print_correlation_report(results, name1="Series 1", name2="Series 2"):
    """
    格式化顯示相關性分析結果

    Parameters:
    -----------
    results : dict
        analyze_correlations 函數返回的結果字典
    name1, name2 : str
        兩個時間序列的名稱
    """
    if "error" in results:
        print(f"錯誤: {results['error']}")
        return

    print(f"\n===== {name1} 與 {name2} 相關性分析 =====")
    print(f"皮爾森相關係數: {results['pearson']:.4f}")
    print(f"斯皮爾曼等級相關係數: {results['spearman']:.4f}")
    print(f"肯德爾陶相關係數: {results['kendall']:.4f}")

    print("\n每年相關性:")
    for year, corr in results["yearly_correlation"].items():
        if corr is not None:
            print(f"{year}年: {corr:.4f}")
        else:
            print(f"{year}年: 數據不足")

    print("\n滾動相關性統計:")
    print("30天滾動窗口:")
    print(results["rolling_corr_30d"].describe())
    print("\n90天滾動窗口:")
    print(results["rolling_corr_90d"].describe())

# 買進持有 00900 ETF
long_position = ~close_all[['00900']].isna().loc['2021-12-22':]
report_00900 = sim(long_position, upload=False)
# report_00900.display()

# 計算相關性
results = analyze_correlations(report.creturn, report_00900.creturn, '復刻策略', '00900 ETF')
print_correlation_report(results, '復刻策略', '00900 ETF')

"""# 優化版"""

import pandas as pd

# --- 輔助函數 ---
def get_trading_day_of_month(year, month, day_number, trading_dates):
    """取得某年某月第 N 個交易日"""
    month_dates = trading_dates[(trading_dates.year == year) & (trading_dates.month == month)]
    if len(month_dates) >= day_number:
        return month_dates[day_number - 1]
    return None

def get_last_trading_day_of_month(year, month, trading_dates):
    """取得某年某月最後一個交易日"""
    month_dates = trading_dates[(trading_dates.year == year) & (trading_dates.month == month)]
    if len(month_dates) > 0:
        return month_dates[-1]
    return None

def get_nearest_future_trading_date(target_date, trading_dates):
    """找到等於或在 target_date 之後的第一個交易日"""
    if target_date is None or target_date > trading_dates[-1]:
        return None
    try:
        return trading_dates[trading_dates.searchsorted(target_date)]
    except IndexError:
        return None

def get_nearest_past_trading_date(target_date, trading_dates):
    """找到等於或在 target_date 之前的最後一個交易日"""
    if target_date is None or target_date < trading_dates[0]:
        return None
    try:
        idx = trading_dates.searchsorted(target_date, side='right')
        # Handle edge case where target_date is before the first date
        if idx == 0:
            return None
        return trading_dates[idx - 1]
    except IndexError:
        return None

# --- 調倉日期計算模塊 ---
def calculate_review_dates(trading_dates: pd.DatetimeIndex):
    """
    計算台灣高股息 30 指數的審核與調倉日期

    台灣高股息 30 指數規則:
    - 4月: 第7個交易日為審核基準日，審核資料截至3月最後交易日
    - 7月: 第7個交易日為審核基準日，審核資料截至6月最後交易日
    - 12月: 第7個交易日為審核基準日，審核資料截至11月最後交易日
    - 生效日: 審核基準日後第5個交易日
    """
    review_dates_info = []
    start_year = trading_dates[0].year
    end_year = trading_dates[-1].year

    for year in range(start_year, end_year + 1):
        # 4月定審
        apr_review_basis_day = get_trading_day_of_month(year, 4, 7, trading_dates)
        mar_data_cutoff_day = get_last_trading_day_of_month(year, 3, trading_dates)

        if apr_review_basis_day and mar_data_cutoff_day:
            target_effective_day_index = trading_dates.searchsorted(apr_review_basis_day) + 5
            if target_effective_day_index < len(trading_dates):
                apr_effective_day_target = trading_dates[target_effective_day_index]
                apr_effective_day = get_nearest_future_trading_date(apr_effective_day_target, trading_dates)
                if apr_effective_day:
                    review_dates_info.append({
                        'year': year,
                        'month': 4,
                        'cutoff_date': mar_data_cutoff_day,
                        'basis_date': apr_review_basis_day,
                        'effective_date': apr_effective_day
                    })

        # 7月定審
        jul_review_basis_day = get_trading_day_of_month(year, 7, 7, trading_dates)
        jun_data_cutoff_day = get_last_trading_day_of_month(year, 6, trading_dates)

        if jul_review_basis_day and jun_data_cutoff_day:
            target_effective_day_index = trading_dates.searchsorted(jul_review_basis_day) + 5
            if target_effective_day_index < len(trading_dates):
                jul_effective_day_target = trading_dates[target_effective_day_index]
                jul_effective_day = get_nearest_future_trading_date(jul_effective_day_target, trading_dates)
                if jul_effective_day:
                    review_dates_info.append({
                        'year': year,
                        'month': 7,
                        'cutoff_date': jun_data_cutoff_day,
                        'basis_date': jul_review_basis_day,
                        'effective_date': jul_effective_day
                    })

        # 12月定審
        dec_review_basis_day = get_trading_day_of_month(year, 12, 7, trading_dates)
        nov_data_cutoff_day = get_last_trading_day_of_month(year, 11, trading_dates)

        if dec_review_basis_day and nov_data_cutoff_day:
            target_effective_day_index = trading_dates.searchsorted(dec_review_basis_day) + 5
            if target_effective_day_index < len(trading_dates):
                dec_effective_day_target = trading_dates[target_effective_day_index]
                dec_effective_day = get_nearest_future_trading_date(dec_effective_day_target, trading_dates)
                if dec_effective_day:
                    review_dates_info.append({
                        'year': year,
                        'month': 12,
                        'cutoff_date': nov_data_cutoff_day,
                        'basis_date': dec_review_basis_day,
                        'effective_date': dec_effective_day
                    })

    # 按生效日期排序
    review_dates_info = sorted(review_dates_info, key=lambda x: x['effective_date'])
    # 移除無效日期
    review_dates_info = [info for info in review_dates_info if info['effective_date'] is not None]

    if not review_dates_info:
        raise ValueError("無法計算出任何有效的審核與生效日期，請檢查日期計算邏輯或資料範圍。")

    return review_dates_info

print("計算審核與生效日期...")
close_all = data.get('price:收盤價')
all_trading_dates = pd.to_datetime(close_all.index)

review_dates_info = calculate_review_dates(all_trading_dates)
basis_dates = pd.DatetimeIndex([info['basis_date'] for info in review_dates_info])
effective_dates = pd.DatetimeIndex([info['effective_date'] for info in review_dates_info])
# 上市與上櫃股票為母體

def fill_dividend_to_adjust_day(cash_dividend, adjust_dates, direction='forward'):
    """
    將股利資料填入特定期間內的調整日期。
    """
    if not isinstance(cash_dividend, pd.DataFrame):
        raise TypeError("cash_dividend must be a pandas DataFrame.")
    if not pd.api.types.is_datetime64_any_dtype(cash_dividend.index):
        try:
            cash_dividend.index = pd.to_datetime(cash_dividend.index)
        except Exception as e:
            raise TypeError(f"cash_dividend.index must be a DatetimeIndex or convertible to datetime. Error: {e}")

    try:
        adjust_dates_dt = pd.to_datetime(adjust_dates)
    except Exception as e:
        raise TypeError(f"adjust_dates must be convertible to datetime. Error: {e}")

    if cash_dividend.empty or len(adjust_dates_dt) == 0:
        # Return empty DataFrame with correct structure if inputs are empty
        return FinlabDataFrame(index=adjust_dates_dt, columns=cash_dividend.columns)

    # 建立調整日期區間結束點
    period_ends = pd.Series(adjust_dates_dt).shift(-1)
    period_ends.iloc[-1] = pd.Timestamp.max

    # 將 cash_dividend 轉為長格式 (Long format)
    dividend_long = cash_dividend.stack(dropna=True).reset_index()
    dividend_long.columns = ['div_date', 'stock', 'dividend']

    # 確保欄位類型正確 (Ensure correct data types)
    dividend_long['stock'] = dividend_long['stock'].astype(str)

    # 建立調整日與股票的交叉資料表
    adj_dates_df = pd.DataFrame(
        [(d, s) for d in adjust_dates_dt for s in cash_dividend.columns],
        columns=['adj_date', 'stock']
    )
    # Ensure correct data types
    adj_dates_df['stock'] = adj_dates_df['stock'].astype(str)

    # 建立從調整日到區間結束點的映射
    adj_date_to_period_end = pd.Series(period_ends.values, index=adjust_dates_dt)
    adj_dates_df['period_end'] = adj_dates_df['adj_date'].map(adj_date_to_period_end)

    # 使用 merge_asof 進行時間點匹配
    merged = pd.merge_asof(
        adj_dates_df.sort_values('adj_date'),
        dividend_long.sort_values('div_date'),
        left_on='adj_date',
        right_on='div_date',
        by='stock',
        direction=direction
    )

    # 篩選: 保留除息日落在調整期間內的股利值
    merged['dividend'] = np.where(
        (merged['div_date'].notna()) & (merged['div_date'] < merged['period_end']),
        merged['dividend'],
        np.nan
    )

    # 重整回寬格式 (Pivot back to wide format)
    result = merged.pivot(index='adj_date', columns='stock', values='dividend')

    # 確保所有原始股票ID都存在於結果中，即使它們沒有任何匹配的股利
    result = result.reindex(columns=cash_dividend.columns)
    # 確保所有原始調整日期都存在於結果中
    result = result.reindex(index=adjust_dates_dt)

    return FinlabDataFrame(result)

close_all = data.get('price:收盤價')
with data.universe(market='TSE_OTC'):
    市值 = data.get('etl:market_value')
    close = data.get('price:收盤價')['2021-12-22':]
    volume = data.get('price:成交股數')
    trans_amount = data.get('price:成交金額')

    # 計算現金股利
    def 計算盈餘分配現金股利():
        df = data.get('dividend_announcement')
        dates = df['除息交易日']

        cash_dividend = FinlabDataFrame(data.get('dividend_announcement')\
        .drop_duplicates(['stock_id', '盈餘分配之股東現金股利(元/股)'], keep='first')\
        .groupby([df.stock_id, dates])\
        .first()['盈餘分配之股東現金股利(元/股)']\
        .dropna().reset_index()\
        .pivot(index='除息交易日', columns='stock_id', values='盈餘分配之股東現金股利(元/股)')\
        )
        return cash_dividend

    def 計算董事決定分配現金股利():
        df = data.get('board_dividend_announcement')
        dates = df['股東會日期'].fillna(df['董事會決議（擬議）股利分派日'])
        board_cash_dividend = FinlabDataFrame(data.get('board_dividend_announcement')\
        .drop_duplicates(['stock_id', '股東配發之現金(股利)總金額(元)'], keep='first')\
        .groupby([df.stock_id, dates])\
        .first()['盈餘分配之現金股利(元/股)']\
        .dropna().reset_index()\
        .pivot(index='股東會日期', columns='stock_id', values='盈餘分配之現金股利(元/股)'))\
        .rename_axis('date').rename_axis('symbol', axis=1)
        return board_cash_dividend

    # 採樣母體
    # 市值前 200 大股票
    市值條件 = 市值.is_largest(200)

    # 成分股篩選標準
    # 最近三個月日均成交金額前 90% 股票納入合格名單
    turnover_3m = trans_amount.rolling(60).mean()  # 約3個月
    流動性條件 = turnover_3m.rank(axis=1, pct=True) >= 0.1  # 取前 90%

    # 近四季營業利益總和為正
    營業利益 = data.get('fundamental_features:營業利益')
    營業利益_4Q = 營業利益.rolling(4).sum()  # 計算近四季營業利益總和
    獲利條件 = (營業利益_4Q > 0)  # 近四季營業利益總和為正

    基本條件 = close > 0
    # 選股條件整合
    conds = (
        基本條件
        & 市值條件
        & 流動性條件
        & 獲利條件
    )


    board_cash_dividend = FinlabDataFrame(計算董事決定分配現金股利())#.ffill().fillna(0)
    cash_dividend = FinlabDataFrame(計算盈餘分配現金股利())#.ffill().fillna(0)
    近四季現金股利總和 = cash_dividend.ffill().fillna(0).resample('Q').last().rolling(4).sum()
    yield_ratio = data.get('price_earning_ratio:殖利率(%)')
    cash_dividend_annual = FinlabDataFrame((cash_dividend / close).rolling(520, min_periods=1).sum())

    # 計算各期股利率
    filled_board_cash_dividend = fill_dividend_to_adjust_day(board_cash_dividend, effective_dates, direction='backward')
    filled_cash_dividend = fill_dividend_to_adjust_day(cash_dividend, effective_dates, direction='forward')

    # 四月股利率計算
    已公告股利 = (filled_board_cash_dividend.reindex(index=close.index) > 0)
    股利率 = (近四季現金股利總和 / close)
    未公告股利 = ~已公告股利
    EPS = data.get('fundamental_features:每股稅後淨利')
    最近四季_EPS_總和 = EPS.rolling(4).sum()
    現金股利發放率 = cash_dividend.ffill().fillna(0).resample('Q').last() / EPS
    過去三年平均現金股利發放率 = 現金股利發放率.resample('D').last().ffill().fillna(0).rolling(720, min_periods=1).mean()

    undeclared_yield = (最近四季_EPS_總和 * 過去三年平均現金股利發放率)/close
    # 四月股利率計算
    四月股利率 = 已公告股利 * 股利率 + 未公告股利 * undeclared_yield
    # 七月股利率計算
    七月股利率 = (近四季現金股利總和 / close)
    # 十二月股利率計算
    十二月股利率 = (最近四季_EPS_總和 * 過去三年平均現金股利發放率)/close

position = ((七月股利率.rank(axis=1, pct=True) + 十二月股利率.rank(axis=1, pct=True) + yield_ratio.rank(axis=1, pct=True))* conds).is_largest(30)


report2 = sim(position.loc['2021-12-22':], resample=effective_dates, upload=False)
report2.display()

report.creturn.plot()
report2.creturn.plot()