{
  "analysis": {
    "test_config": {
      "total_iterations": 20,
      "innovation_rate": 0.2,
      "llm_expected": 4,
      "timestamp": "2025-10-30T16:53:37.588739"
    },
    "execution_summary": {
      "llm_attempts": 5,
      "llm_success": 4,
      "llm_success_rate": 0.8,
      "fallback_count": 15,
      "total_success": 19
    },
    "champion": {
      "sharpe": 2.4751337704804173,
      "timestamp": "2025-10-08T12:40:12.725776"
    },
    "llm_quality": {
      "count": 4,
      "avg_sharpe": 1.980107016384334,
      "best_sharpe": 1.980107016384334,
      "avg_quality_score": 0.525,
      "best_quality_score": 0.525,
      "quality_tiers": {
        "Excellent": 0,
        "Good": 4,
        "Acceptable": 0,
        "Needs Improvement": 0
      },
      "beats_champion": false
    },
    "success_criteria": {
      "iterations_completed": true,
      "llm_success_rate_ok": true,
      "llm_count_ok": true,
      "champion_unchanged": true
    },
    "recommendation": "Good - Proceed to Phase 2 or test Grok"
  },
  "detailed_results": [
    {
      "iteration": 0,
      "timestamp": "2025-10-30T16:53:02.392677",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 1,
      "timestamp": "2025-10-30T16:53:02.893470",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 2,
      "timestamp": "2025-10-30T16:53:03.394283",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 3,
      "timestamp": "2025-10-30T16:53:03.894788",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 4,
      "timestamp": "2025-10-30T16:53:04.395455",
      "source": "llm",
      "success": true,
      "code": "\"\"\"\nChampion Momentum Strategy\n==========================\n\nA robust momentum strategy designed to achieve a high Sharpe Ratio (2.48) by focusing on strong trending assets while avoiding overtrading and large drawdowns. It uses a combination of RSI and MACD for trend confirmation, and a custom momentum score for ranking. Position sizing is volatility-weighted to manage risk.\n\nStrategy Type: momentum\nRebalancing: W-FRI\nGenerated from YAML specification\n\"\"\"\n\ndef strategy(data):\n    \"\"\"\n    Champion Momentum Strategy\n\n    This strategy was auto-generated from a YAML specification.\n\n    Strategy Parameters:\n    - Type: momentum\n    - Rebalancing: W-FRI    \"\"\"\n\n    # ========================================================================\n    # Load Base Data\n    # ========================================================================\n    close = data.get('price:收盤價')\n    volume = data.get('price:成交股數')\n    # ========================================================================\n    # Load Technical Indicators\n    # ========================================================================    rsi_14 = data.get('RSI_14')  # RSI (period=14)    macd_12_26_9 = data.get('MACD_12_26_9')  # MACD (period=12)    atr_14 = data.get('ATR_14')  # ATR (period=14)    ema_50 = data.get('EMA_50')  # EMA (period=50)\n    # ========================================================================\n    # Custom Calculations\n    # ========================================================================    momentum_score = rsi_14 * (macd_12_26_9.macd - macd_12_26_9.signal)  # \n    # ========================================================================\n    # Entry Conditions\n    # ========================================================================\n    # Threshold-based filters    filter_1 = (rsi_14 > 60)  # RSI indicates strong upward momentum.    filter_2 = (macd_12_26_9.macd > macd_12_26_9.signal)  # MACD line is above its signal line, confirming upward trend.    filter_3 = (close > ema_50)  # Price is above the 50-day exponential moving average, indicating a bullish trend.    filter_4 = (momentum_score > 0)  # Custom momentum score is positive.\n    # Liquidity filters    liquidity_filter_volume = volume.rolling(20).mean() > 50000000\n    # Combine threshold filters    threshold_mask = filter_1 & filter_2 & filter_3 & filter_4    threshold_mask = threshold_mask & liquidity_filter_volume\n    # No ranking rules - use threshold mask only\n    entry_mask = threshold_mask\n    # ========================================================================\n    # Position Sizing\n    # ========================================================================\n    # Volatility-weighted (inverse volatility)\n    returns = close.pct_change()\n    volatility = returns.rolling(60).std()\n    inv_vol = 1.0 / volatility\n    weights = inv_vol[entry_mask]\n    weights = weights / weights.sum(axis=1).values.reshape(-1, 1)\n    position = weights\n    # Apply maximum position size limit\n    position = position.clip(upper=0.07)\n    position = position / position.sum(axis=1).values.reshape(-1, 1)\n    return position\n",
      "generation_time": 3.487215757369995,
      "code_length": 3117,
      "code_path": "artifacts/data/phase1_strategy_iter4.py",
      "metrics": {
        "sharpe_ratio": 1.980107016384334,
        "annual_return": 0.08367696947996167,
        "max_drawdown": -0.18286607610319808,
        "win_rate": 0.28446146392847876,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 0.75,
        "return_score": 0.5,
        "calmar_score": 0.25,
        "performance_total": 0.225,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "novel_factors": true,
        "structural_innovation": true,
        "innovation_total": 0.15000000000000002,
        "total_score": 0.525,
        "quality_tier": "Good"
      }
    },
    {
      "iteration": 5,
      "timestamp": "2025-10-30T16:53:08.394627",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 6,
      "timestamp": "2025-10-30T16:53:08.896020",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 7,
      "timestamp": "2025-10-30T16:53:09.397354",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 8,
      "timestamp": "2025-10-30T16:53:09.898128",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 9,
      "timestamp": "2025-10-30T16:53:10.399323",
      "source": "llm",
      "success": true,
      "code": "\"\"\"\nChampion Momentum Builder\n=========================\n\nA momentum strategy designed to capture strong trends while managing drawdowns and avoiding overtrading, aiming for high Sharpe ratio.\n\nStrategy Type: momentum\nRebalancing: W-FRI\nGenerated from YAML specification\n\"\"\"\n\ndef strategy(data):\n    \"\"\"\n    Champion Momentum Builder\n\n    This strategy was auto-generated from a YAML specification.\n\n    Strategy Parameters:\n    - Type: momentum\n    - Rebalancing: W-FRI    \"\"\"\n\n    # ========================================================================\n    # Load Base Data\n    # ========================================================================\n    close = data.get('price:收盤價')\n    volume = data.get('price:成交股數')\n    # ========================================================================\n    # Load Technical Indicators\n    # ========================================================================    ema_50 = data.get('close')  # EMA (period=50)    ema_200 = data.get('close')  # EMA (period=200)    rsi_14 = data.get('close')  # RSI (period=14)    atr_14 = data.get('high') - data.get('low')  # ATR (period=14)\n    # ========================================================================\n    # Custom Calculations\n    # ========================================================================    trend_strength = ema_50 / ema_200  #     volatility_adjusted_rsi = rsi_14 / (atr_14 / close)  # \n    # ========================================================================\n    # Entry Conditions\n    # ========================================================================\n    # Threshold-based filters    filter_1 = (trend_strength > 1.05)  # Price is in a strong uptrend (50-day EMA significantly above 200-day EMA).    filter_2 = (volatility_adjusted_rsi > 2.5)  # RSI indicates strong upward momentum, adjusted for volatility to avoid whipsaws.    filter_3 = (rsi_14 < 70)  # Avoid entering when RSI is already overbought, to reduce immediate pullback risk.\n    # Combine threshold filters    threshold_mask = filter_1 & filter_2 & filter_3\n    # No ranking rules - use threshold mask only\n    entry_mask = threshold_mask\n    # ========================================================================\n    # Position Sizing\n    # ========================================================================\n    # Volatility-weighted (inverse volatility)\n    returns = close.pct_change()\n    volatility = returns.rolling(60).std()\n    inv_vol = 1.0 / volatility\n    weights = inv_vol[entry_mask]\n    weights = weights / weights.sum(axis=1).values.reshape(-1, 1)\n    position = weights\n    # Apply maximum position size limit\n    position = position.clip(upper=0.08)\n    position = position / position.sum(axis=1).values.reshape(-1, 1)\n    return position\n",
      "generation_time": 3.0405592918395996,
      "code_length": 2777,
      "code_path": "artifacts/data/phase1_strategy_iter9.py",
      "metrics": {
        "sharpe_ratio": 1.980107016384334,
        "annual_return": 0.08367696947996167,
        "max_drawdown": -0.18286607610319808,
        "win_rate": 0.28446146392847876,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 0.75,
        "return_score": 0.5,
        "calmar_score": 0.25,
        "performance_total": 0.225,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "novel_factors": true,
        "structural_innovation": true,
        "innovation_total": 0.15000000000000002,
        "total_score": 0.525,
        "quality_tier": "Good"
      }
    },
    {
      "iteration": 10,
      "timestamp": "2025-10-30T16:53:13.951297",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 11,
      "timestamp": "2025-10-30T16:53:14.451676",
      "source": "llm",
      "success": false,
      "error": "No code generated"
    },
    {
      "iteration": 12,
      "timestamp": "2025-10-30T16:53:28.343522",
      "source": "llm",
      "success": true,
      "code": "\"\"\"\nChampion Momentum Strategy\n==========================\n\nA robust momentum strategy designed to achieve a Sharpe Ratio of 2.48, prioritizing capital preservation by avoiding overtrading and large drawdowns.\n\nStrategy Type: momentum\nRebalancing: M\nGenerated from YAML specification\n\"\"\"\n\ndef strategy(data):\n    \"\"\"\n    Champion Momentum Strategy\n\n    This strategy was auto-generated from a YAML specification.\n\n    Strategy Parameters:\n    - Type: momentum\n    - Rebalancing: M    \"\"\"\n\n    # ========================================================================\n    # Load Base Data\n    # ========================================================================\n    close = data.get('price:收盤價')\n    volume = data.get('price:成交股數')\n    # ========================================================================\n    # Load Technical Indicators\n    # ========================================================================    rsi_14 = data.get('RSI_14')  # RSI (period=14)    ema_50 = data.get('EMA_50')  # EMA (period=50)    atr_14 = data.get('ATR_14')  # ATR (period=14)\n    # ========================================================================\n    # Custom Calculations\n    # ========================================================================    momentum_score = rsi_14 * (close / ema_50)  # \n    # ========================================================================\n    # Entry Conditions\n    # ========================================================================\n    # Threshold-based filters    filter_1 = (momentum_score > 60)  # Strong upward momentum indicated by RSI and price relative to EMA.    filter_2 = (close > ema_50)  # Price is trading above the 50-period Exponential Moving Average.    filter_3 = (rsi_14 < 80)  # Avoid entering when RSI is excessively overbought to reduce immediate reversal risk.\n    # Combine threshold filters    threshold_mask = filter_1 & filter_2 & filter_3\n    # No ranking rules - use threshold mask only\n    entry_mask = threshold_mask\n    # ========================================================================\n    # Position Sizing\n    # ========================================================================\n    # Volatility-weighted (inverse volatility)\n    returns = close.pct_change()\n    volatility = returns.rolling(60).std()\n    inv_vol = 1.0 / volatility\n    weights = inv_vol[entry_mask]\n    weights = weights / weights.sum(axis=1).values.reshape(-1, 1)\n    position = weights\n    # Apply maximum position size limit\n    position = position.clip(upper=0.07)\n    position = position / position.sum(axis=1).values.reshape(-1, 1)\n    return position\n",
      "generation_time": 2.0548839569091797,
      "code_length": 2634,
      "code_path": "artifacts/data/phase1_strategy_iter12.py",
      "metrics": {
        "sharpe_ratio": 1.980107016384334,
        "annual_return": 0.08367696947996167,
        "max_drawdown": -0.18286607610319808,
        "win_rate": 0.28446146392847876,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 0.75,
        "return_score": 0.5,
        "calmar_score": 0.25,
        "performance_total": 0.225,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "novel_factors": true,
        "structural_innovation": true,
        "innovation_total": 0.15000000000000002,
        "total_score": 0.525,
        "quality_tier": "Good"
      }
    },
    {
      "iteration": 13,
      "timestamp": "2025-10-30T16:53:30.910142",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 14,
      "timestamp": "2025-10-30T16:53:31.410646",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 15,
      "timestamp": "2025-10-30T16:53:31.911233",
      "source": "llm",
      "success": true,
      "code": "\"\"\"\nChampion Momentum Strategy\n==========================\n\nA robust momentum strategy designed to achieve a high Sharpe Ratio (2.48) by focusing on strong trending assets, avoiding overtrading and large drawdowns.\n\nStrategy Type: momentum\nRebalancing: W-FRI\nGenerated from YAML specification\n\"\"\"\n\ndef strategy(data):\n    \"\"\"\n    Champion Momentum Strategy\n\n    This strategy was auto-generated from a YAML specification.\n\n    Strategy Parameters:\n    - Type: momentum\n    - Rebalancing: W-FRI    \"\"\"\n\n    # ========================================================================\n    # Load Base Data\n    # ========================================================================\n    close = data.get('price:收盤價')\n    volume = data.get('price:成交股數')\n    # ========================================================================\n    # Load Technical Indicators\n    # ========================================================================    rsi_14 = data.get('RSI_14')  # RSI (period=14)    ema_50 = data.get('EMA_50')  # EMA (period=50)    ema_200 = data.get('EMA_200')  # EMA (period=200)    atr_14 = data.get('ATR_14')  # ATR (period=14)\n    # ========================================================================\n    # Custom Calculations\n    # ========================================================================    momentum_score = (close - open) / open * 100  #     trend_strength = ema_50 / ema_200  # \n    # ========================================================================\n    # Entry Conditions\n    # ========================================================================\n    # Threshold-based filters    filter_1 = (rsi_14 > 55)  # RSI indicating strong upward momentum    filter_2 = (close > ema_50)  # Price above short-term EMA    filter_3 = (ema_50 > ema_200)  # Short-term EMA above long-term EMA (uptrend confirmation)    filter_4 = (momentum_score > 1.0)  # Positive intra-day momentum    filter_5 = (trend_strength > 1.05)  # Confirmed upward trend\n    # Liquidity filters    liquidity_filter_volume = volume.rolling(20).mean() > 50000000\n    # Combine threshold filters    threshold_mask = filter_1 & filter_2 & filter_3 & filter_4 & filter_5    threshold_mask = threshold_mask & liquidity_filter_volume\n    # No ranking rules - use threshold mask only\n    entry_mask = threshold_mask\n    # ========================================================================\n    # Position Sizing\n    # ========================================================================\n    # Volatility-weighted (inverse volatility)\n    returns = close.pct_change()\n    volatility = returns.rolling(60).std()\n    inv_vol = 1.0 / volatility\n    weights = inv_vol[entry_mask]\n    weights = weights / weights.sum(axis=1).values.reshape(-1, 1)\n    position = weights\n    # Apply maximum position size limit\n    position = position.clip(upper=0.08)\n    position = position / position.sum(axis=1).values.reshape(-1, 1)\n    return position\n",
      "generation_time": 3.1633732318878174,
      "code_length": 2951,
      "code_path": "artifacts/data/phase1_strategy_iter15.py",
      "metrics": {
        "sharpe_ratio": 1.980107016384334,
        "annual_return": 0.08367696947996167,
        "max_drawdown": -0.18286607610319808,
        "win_rate": 0.28446146392847876,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 0.75,
        "return_score": 0.5,
        "calmar_score": 0.25,
        "performance_total": 0.225,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "novel_factors": true,
        "structural_innovation": true,
        "innovation_total": 0.15000000000000002,
        "total_score": 0.525,
        "quality_tier": "Good"
      }
    },
    {
      "iteration": 16,
      "timestamp": "2025-10-30T16:53:35.586365",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 17,
      "timestamp": "2025-10-30T16:53:36.086829",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 18,
      "timestamp": "2025-10-30T16:53:36.587259",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    },
    {
      "iteration": 19,
      "timestamp": "2025-10-30T16:53:37.088032",
      "source": "factor_graph",
      "success": true,
      "code": "# 1. Load data\nclose = data.get('price:收盤價')\nvolume = data.get('price:成交股數')\nrevenue_yoy = data.get('monthly_revenue:去年同月增減(%)')\nroe = data.get('fundamental_features:ROE稅後')\npe_ratio = data.get('price_earning_ratio:本益比')\n\n# 2. Calculate factors\n# Momentum factor (20-day return)\nreturns_20d = close.pct_change(20).shift(1)\n\n# Revenue growth factor (YoY)\nrevenue_growth_factor = revenue_yoy.shift(1)\n\n# ROE factor\nroe_factor = roe.shift(1)\n\n# Inverse P/E ratio factor (lower P/E is better)\n# Handle potential division by zero or negative P/E\ninverse_pe_factor = (1 / pe_ratio).replace([float('inf'), -float('inf')], 0).shift(1)\n\n# 3. Combine factors\n# Normalize factors (simple min-max normalization for illustration, though Finlab often handles this implicitly)\n# For simplicity, we'll combine directly, assuming relative ranking is what matters.\n# Higher returns, higher revenue growth, higher ROE, lower PE are generally better.\ncombined_factor = (\n    returns_20d * 0.3 +\n    revenue_growth_factor * 0.3 +\n    roe_factor * 0.2 +\n    inverse_pe_factor * 0.2\n)\n\n# 4. Apply filters\n# Liquidity filter: average daily trading value over 20 days > 50 million TWD\ntrading_value = data.get('price:成交金額')\nliquidity_filter = trading_value.rolling(20).mean().shift(1) > 50_000_000\n\n# Price filter: stock price > 10 TWD\nprice_filter = close.shift(1) > 10\n\n# Combine filters\nfinal_filter = liquidity_filter & price_filter\n\n# 5. Select stocks\n# Apply filters and select the top 10 stocks based on the combined factor\nposition = combined_factor[final_filter].is_largest(10)\n\n# 6. Run backtest\nreport = sim(position, resample=\"Q\", upload=False, stop_loss=0.08)",
      "metrics": {
        "total_return": 0.43943126047094666,
        "annual_return": 0.11953852782851668,
        "sharpe_ratio": 2.4751337704804173,
        "max_drawdown": -0.15238839675266508,
        "win_rate": 0.31606829325386526,
        "position_count": 3277
      },
      "quality": {
        "sharpe_score": 1.0,
        "return_score": 0.5,
        "calmar_score": 0.5,
        "performance_total": 0.3,
        "drawdown_score": 0.5,
        "risk_total": 0.075,
        "winrate_score": 0.25,
        "position_score": 1.0,
        "practical_total": 0.07500000000000001,
        "innovation_total": 0.0,
        "total_score": 0.45,
        "quality_tier": "Acceptable"
      }
    }
  ]
}