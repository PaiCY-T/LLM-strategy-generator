> """
> PromptBuilder - Constructs effective LLM prompts with feedback loops
  
> Creates modification and creation prompts that incorporate:
> - Champion strategy feedback (code, metrics, success factors)
> - Failure pattern extraction from historical failures
> - FinLab API constraints and requirements
> - Few-shot examples for guidance
> - Token budget management (<2000 tokens)
  
> Requirements: 3.1, 3.2, 3.3
> """
  
> import json
> import re
> from typing import Dict, List, Optional, Any, Tuple
> from pathlib import Path
  
  
  # Token budget constraints
> MAX_PROMPT_TOKENS = 2000  # Stay under 2000 tokens
> CHARS_PER_TOKEN = 4  # Rough estimate: 1 token ≈ 4 characters
> MAX_PROMPT_CHARS = MAX_PROMPT_TOKENS * CHARS_PER_TOKEN  # ~8000 chars
  
  # Liquidity requirement (million TWD)
> MIN_LIQUIDITY_MILLIONS = 150
  
  
> class PromptBuilder:
>     """
>     Builds prompts for LLM-driven strategy innovation.
  
>     Supports two modes:
>     1. Modification: Modify existing champion strategy to improve metrics
>     2. Creation: Create novel strategy inspired by champion approach
  
>     Integrates feedback loops:
>     - Success factors from champion code/metrics
>     - Failure patterns from failure_patterns.json
>     - FinLab API constraints
>     """
  
>     def __init__(self, failure_patterns_path: str = "artifacts/data/failure_patterns.json"):
>         """
>         Initialize PromptBuilder.
  
>         Args:
>             failure_patterns_path: Path to failure patterns JSON file
>         """
>         self.failure_patterns_path = failure_patterns_path
>         self._cached_failure_patterns: Optional[List[Dict[str, Any]]] = None
  
>     def build_modification_prompt(
>         self,
>         champion_code: str,
>         champion_metrics: Dict[str, float],
>         failure_history: Optional[List[Dict[str, Any]]] = None,
>         target_metric: str = "sharpe_ratio"
>     ) -> str:
>         """
>         Build prompt for modifying champion strategy to improve metrics.
  
>         Args:
>             champion_code: Current champion strategy code
>             champion_metrics: Champion performance metrics (sharpe, mdd, win_rate, etc.)
>             failure_history: Optional recent failure history (last 3 failures)
>             target_metric: Which metric to optimize (default: sharpe_ratio)
  
>         Returns:
>             Complete modification prompt (under 2000 tokens)
  
>         Example:
>             >>> builder = PromptBuilder()
>             >>> prompt = builder.build_modification_prompt(
>             ...     champion_code="def strategy(data): ...",
>             ...     champion_metrics={"sharpe_ratio": 0.85, "max_drawdown": 0.15},
>             ...     target_metric="sharpe_ratio"
>             ... )
>         """
          # Extract success factors from champion
>         success_factors = self.extract_success_factors(champion_code, champion_metrics)
  
          # Extract failure patterns (limit to recent ones)
>         failure_patterns = []
>         if failure_history:
>             failure_patterns = self._format_failure_patterns(failure_history[:3])
  
          # Build prompt sections
>         prompt_parts = [
>             self._get_modification_header(),
>             self._format_champion_context(champion_code, champion_metrics, success_factors),
>             self._format_target_directive(target_metric, champion_metrics),
>             self._format_constraints(),
>             self._format_failure_avoidance(failure_patterns),
>             self._get_modification_example(),
>             self._get_output_format()
>         ]
  
          # Combine and truncate if needed
>         prompt = "\n\n".join(prompt_parts)
>         return self._truncate_to_budget(prompt)
  
>     def build_creation_prompt(
>         self,
>         champion_approach: str,
>         failure_patterns: Optional[List[Dict[str, Any]]] = None,
>         innovation_directive: str = "Create a novel strategy with different factor combinations"
>     ) -> str:
>         """
>         Build prompt for creating novel strategy inspired by champion.
  
>         Args:
>             champion_approach: High-level description of champion's approach
>             failure_patterns: Known failure patterns to avoid
>             innovation_directive: Specific innovation guidance
  
>         Returns:
>             Complete creation prompt (under 2000 tokens)
  
>         Example:
>             >>> builder = PromptBuilder()
>             >>> prompt = builder.build_creation_prompt(
>             ...     champion_approach="Momentum-based factor with ROE filter",
>             ...     innovation_directive="Explore value + quality combinations"
>             ... )
>         """
          # Load and extract failure patterns from JSON if not provided
>         if failure_patterns is None:
>             failure_patterns = self.extract_failure_patterns()
  
          # Build prompt sections
>         prompt_parts = [
>             self._get_creation_header(),
>             self._format_champion_inspiration(champion_approach),
>             self._format_innovation_directive(innovation_directive),
>             self._format_constraints(),
>             self._format_failure_avoidance(self._format_failure_patterns(failure_patterns[:5])),
>             self._get_creation_example(),
>             self._get_output_format()
>         ]
  
          # Combine and truncate if needed
>         prompt = "\n\n".join(prompt_parts)
>         return self._truncate_to_budget(prompt)
  
>     def extract_success_factors(
>         self,
>         code: str,
>         metrics: Dict[str, float]
>     ) -> List[str]:
>         """
>         Extract success factors from champion code and metrics.
  
>         Identifies key patterns that contributed to champion's success:
>         - High-performing metrics (Sharpe, Calmar, Win Rate)
>         - Code patterns (data sources, filters, factor combinations)
>         - Risk management patterns (liquidity filters, rebalancing)
  
>         Args:
>             code: Champion strategy code
>             metrics: Performance metrics
  
>         Returns:
>             List of success factor descriptions
  
>         Example:
>             >>> factors = builder.extract_success_factors(
>             ...     code="factor = data.get('fundamental_features:ROE稅後') > 15",
>             ...     metrics={"sharpe_ratio": 0.95, "max_drawdown": 0.12}
>             ... )
>             >>> # Returns: ["High Sharpe (0.95)", "Low drawdown (0.12)", "Uses ROE filter", ...]
>         """
>         factors = []
  
          # Metric-based success factors
>         sharpe = metrics.get('sharpe_ratio', 0)
>         if sharpe > 0.8:
>             factors.append(f"High Sharpe ratio ({sharpe:.2f})")
  
>         mdd = metrics.get('max_drawdown', 1.0)
>         if mdd < 0.15:
>             factors.append(f"Low max drawdown ({mdd:.2%})")
  
>         win_rate = metrics.get('win_rate', 0)
>         if win_rate > 0.6:
>             factors.append(f"High win rate ({win_rate:.1%})")
  
>         calmar = metrics.get('calmar_ratio', 0)
>         if calmar > 2.0:
>             factors.append(f"Strong Calmar ratio ({calmar:.2f})")
  
          # Code pattern analysis
>         code_lower = code.lower()
  
          # Data source patterns
>         if 'fundamental_features:roe' in code_lower:
>             factors.append("Uses ROE quality filter")
>         if 'fundamental_features:營收成長率' in code_lower or 'revenue_growth' in code_lower:
>             factors.append("Incorporates revenue growth")
>         if 'price:收盤價' in code_lower or 'close' in code_lower:
>             factors.append("Uses price momentum")
  
          # Technical patterns
>         if '.rolling(' in code_lower:
>             factors.append("Uses moving averages/smoothing")
>         if '.shift(' in code_lower:
>             factors.append("Avoids look-ahead bias (proper shift)")
>         if 'rank(' in code_lower:
>             factors.append("Uses cross-sectional ranking")
  
          # Risk management patterns
>         if 'liquidity' in code_lower or '成交量' in code_lower:
>             factors.append("Applies liquidity filter")
>         if 'fillna' in code_lower or 'dropna' in code_lower:
>             factors.append("Handles missing data properly")
  
          # Filter patterns
>         if '>' in code or '<' in code:
>             factors.append("Uses threshold filters")
>         if '&' in code or '|' in code:
>             factors.append("Combines multiple conditions")
  
>         return factors[:6]  # Limit to top 6 factors
  
>     def extract_failure_patterns(
>         self,
>         failure_json_path: Optional[str] = None
>     ) -> List[Dict[str, Any]]:
>         """
>         Extract failure patterns from failure_patterns.json.
  
>         Loads and parses failure patterns with performance impact analysis.
>         Caches results for efficiency.
  
>         Args:
>             failure_json_path: Optional path override (uses default if None)
  
>         Returns:
>             List of failure pattern dictionaries
  
>         Example:
>             >>> patterns = builder.extract_failure_patterns()
>             >>> # Returns: [{"pattern_type": "parameter_change", "description": "...", ...}, ...]
>         """
          # Use cache if available
>         if self._cached_failure_patterns is not None:
>             return self._cached_failure_patterns
  
          # Determine path
>         path = failure_json_path or self.failure_patterns_path
  
>         try:
>             with open(path, 'r', encoding='utf-8') as f:
>                 patterns = json.load(f)
  
              # Cache for future use
>             self._cached_failure_patterns = patterns
>             return patterns
  
>         except FileNotFoundError:
              # Return empty list if file doesn't exist (graceful degradation)
>             return []
>         except json.JSONDecodeError as e:
>             print(f"Warning: Failed to parse {path}: {e}")
>             return []
  
      # ========================================================================
      # Private Helper Methods - Prompt Sections
      # ========================================================================
  
>     def _get_modification_header(self) -> str:
>         """Get modification prompt header."""
>         return """# Task: Modify Champion Strategy to Improve Performance
  
> You are an expert quantitative researcher specializing in Taiwan stock market strategies.
> Your task is to modify the current champion strategy to improve its performance metrics.
  
> **Instructions**:
> - Preserve successful patterns from the champion
> - Make targeted improvements to boost the target metric
> - Maintain all FinLab API constraints
> - Ensure no look-ahead bias
> - Keep the strategy executable and robust"""
  
>     def _get_creation_header(self) -> str:
>         """Get creation prompt header."""
>         return """# Task: Create Novel Trading Strategy
  
> You are an expert quantitative researcher specializing in Taiwan stock market strategies.
> Your task is to create a novel strategy inspired by successful approaches but with new ideas.
  
> **Instructions**:
> - Draw inspiration from champion approach, but create something different
> - Explore new factor combinations or data sources
> - Maintain all FinLab API constraints
> - Ensure no look-ahead bias
> - Ensure the strategy is executable and robust"""
  
>     def _format_champion_context(
>         self,
>         code: str,
>         metrics: Dict[str, float],
>         success_factors: List[str]
>     ) -> str:
>         """Format champion context section."""
          # Truncate code if too long
>         code_preview = code[:400] + "..." if len(code) > 400 else code
  
>         context = f"""## Current Champion Strategy
  
> **Performance**:
> - Sharpe Ratio: {metrics.get('sharpe_ratio', 0):.3f}
> - Max Drawdown: {metrics.get('max_drawdown', 0):.2%}
> - Win Rate: {metrics.get('win_rate', 0):.1%}
> - Calmar Ratio: {metrics.get('calmar_ratio', 0):.2f}
  
> **Success Factors to Preserve**:
> {self._format_list(success_factors)}
  
> **Code Preview**:
> ```python
> {code_preview}
> ```"""
>         return context
  
>     def _format_champion_inspiration(self, champion_approach: str) -> str:
>         """Format champion inspiration section."""
>         return f"""## Champion Approach (for Inspiration)
  
> The current champion uses: {champion_approach}
  
> **Your Task**: Create a NOVEL strategy that explores different directions while
> maintaining robustness and alignment with FinLab constraints."""
  
>     def _format_target_directive(
>         self,
>         target_metric: str,
>         current_metrics: Dict[str, float]
>     ) -> str:
>         """Format target improvement directive."""
>         current_value = current_metrics.get(target_metric, 0)
>         metric_display = target_metric.replace('_', ' ').title()
  
>         return f"""## Optimization Target
  
> **Primary Goal**: Improve {metric_display}
> - Current: {current_value:.3f}
> - Target: >{current_value * 1.1:.3f} (+10% improvement)
  
> **Constraints**:
> - Maintain Max Drawdown <25%
> - Maintain Win Rate >45%
> - Preserve liquidity requirements (>{MIN_LIQUIDITY_MILLIONS}M TWD)"""
  
>     def _format_innovation_directive(self, directive: str) -> str:
>         """Format innovation directive section."""
>         return f"""## Innovation Directive
  
> {directive}
  
> **Exploration Ideas**:
> - Combine factors from different categories (value + momentum, quality + growth)
> - Use alternative data transformations (ratios, ranks, z-scores)
> - Explore sector-specific patterns
> - Implement dynamic filters based on market conditions"""
  
>     def _format_constraints(self) -> str:
>         """Format FinLab API constraints section."""
>         return f"""## FinLab API Constraints
  
> **Required Function Signature**:
> ```python
> def strategy(data):
      # Your strategy logic here
      # Must return: position series or stock selection boolean series
>     return position
> ```
  
> **Data Access** (Taiwan Stock Market):
> - Price: `data.get('price:收盤價')`, `data.get('price:開盤價')`, `data.get('price:成交量')`
> - Fundamentals: `data.get('fundamental_features:ROE稅後')`, `data.get('fundamental_features:本益比')`,
>   `data.get('fundamental_features:營收成長率')`, `data.get('fundamental_features:負債比率')`
> - Technical: Use pandas operations (`.rolling()`, `.shift()`, `.rank()`, etc.)
  
> **Critical Rules**:
> 1. No external imports - use only built-in pandas/numpy operations
> 2. No look-ahead bias - always use `.shift(1)` or higher for historical data
> 3. Handle NaN values - use `.fillna()` or `.dropna()`
> 4. Liquidity filter - ensure average daily volume >{MIN_LIQUIDITY_MILLIONS}M TWD
> 5. Rebalancing - support weekly or monthly rebalancing frequencies
  
> **Validation**:
> - Code must be executable without syntax errors
> - Must handle edge cases (zero divisions, missing data)
> - Must be vectorized (no loops over stocks)"""
  
>     def _format_failure_avoidance(self, failure_list: List[str]) -> str:
>         """Format failure patterns to avoid."""
>         if not failure_list:
>             return "## Failure Patterns\n\nNo historical failures to avoid."
  
>         return f"""## Failure Patterns to Avoid
  
> Based on historical failures, AVOID these patterns:
> {self._format_list(failure_list)}"""
  
>     def _get_modification_example(self) -> str:
>         """Get few-shot modification example."""
>         return """## Example: Successful Modification
  
> **Original Champion**:
> ```python
> def strategy(data):
      # High ROE filter
>     roe = data.get('fundamental_features:ROE稅後')
>     return roe > 15
> ```
> Sharpe: 0.75, MDD: 18%
  
> **Modified Version** (Improvement: +15% Sharpe):
> ```python
> def strategy(data):
      # Add growth filter to high ROE
>     roe = data.get('fundamental_features:ROE稅後')
>     growth = data.get('fundamental_features:營收成長率')
  
      # Combine quality (ROE) with growth momentum
>     quality_growth = (roe > 15) & (growth > 0.1)
  
      # Add liquidity filter
>     volume = data.get('price:成交量')
>     liquidity = volume.rolling(20).mean() > 150_000_000
  
>     return quality_growth & liquidity
> ```
> Sharpe: 0.86 (+15%), MDD: 16%
  
> **Modification Rationale**: Added growth filter to improve returns while maintaining
> quality focus. Liquidity filter reduces transaction costs."""
  
>     def _get_creation_example(self) -> str:
>         """Get few-shot creation example."""
>         return """## Example: Successful Novel Creation
  
> **Champion Approach**: "Momentum-based with ROE filter"
  
> **Novel Strategy** (Different approach: Value + Quality):
> ```python
> def strategy(data):
      # Value: Low P/B ratio
>     pb = data.get('fundamental_features:淨值比')
  
      # Quality: High profit margin
>     profit_margin = data.get('fundamental_features:稅後淨利率')
  
      # Combine: Quality-adjusted value
>     value_score = profit_margin / pb.replace(0, float('nan'))
  
      # Rank and select top 20%
>     ranked = value_score.rank(pct=True, ascending=False)
  
      # Liquidity filter
>     volume = data.get('price:成交量')
>     liquidity = volume.rolling(20).mean() > 150_000_000
  
>     return (ranked > 0.8) & liquidity
> ```
  
> **Creation Rationale**: Novel combination of value (P/B) and quality (profit margin).
> Uses ranking instead of threshold to adapt to market conditions. Different from
> champion's momentum approach."""
  
>     def _get_output_format(self) -> str:
>         """Get output format instructions."""
>         return """## Output Format
  
> Provide your strategy code in this exact format:
  
> ```python
> def strategy(data):
      # Your strategy logic here
      # Include comments explaining key steps
  
>     return position  # Return position series or boolean series
> ```
  
> **Requirements**:
> - Complete, executable Python function
> - No syntax errors
> - Follows all FinLab constraints
> - Includes brief inline comments
> - Maximum 50 lines of code"""
  
      # ========================================================================
      # Private Helper Methods - Formatting
      # ========================================================================
  
>     def _format_list(self, items: List[str]) -> str:
>         """Format list with bullet points."""
>         if not items:
>             return "- None"
>         return "\n".join(f"- {item}" for item in items)
  
>     def _format_failure_patterns(
>         self,
>         patterns: List[Dict[str, Any]]
>     ) -> List[str]:
>         """
>         Convert failure pattern dicts to readable strings.
  
>         Args:
>             patterns: List of failure pattern dictionaries
  
>         Returns:
>             List of formatted failure descriptions
>         """
>         formatted = []
>         for pattern in patterns:
>             desc = pattern.get('description', 'Unknown pattern')
>             impact = pattern.get('performance_impact', 0)
  
              # Format with impact
>             if impact < 0:
>                 formatted.append(f"{desc} (Impact: {impact:.2%} degradation)")
!             else:
!                 formatted.append(desc)
  
>         return formatted
  
>     def _truncate_to_budget(self, prompt: str) -> str:
>         """
>         Truncate prompt to stay within token budget.
  
>         Args:
>             prompt: Full prompt text
  
>         Returns:
>             Truncated prompt if needed
>         """
>         if len(prompt) <= MAX_PROMPT_CHARS:
>             return prompt
  
          # Truncate with warning
>         truncated = prompt[:MAX_PROMPT_CHARS - 100]
>         truncated += f"\n\n[... truncated to fit {MAX_PROMPT_TOKENS} token budget ...]"
  
>         return truncated
  
  
  # Example usage
> if __name__ == "__main__":
!     print("=" * 70)
!     print("TESTING PROMPT BUILDER")
!     print("=" * 70)
  
!     builder = PromptBuilder()
  
      # Test 1: Modification Prompt
!     print("\n" + "=" * 70)
!     print("Test 1: Modification Prompt")
!     print("=" * 70)
  
!     champion_code = """
! def strategy(data):
!     roe = data.get('fundamental_features:ROE稅後')
!     return roe > 15
! """
  
!     champion_metrics = {
!         'sharpe_ratio': 0.85,
!         'max_drawdown': 0.15,
!         'win_rate': 0.58,
!         'calmar_ratio': 2.3
!     }
  
!     mod_prompt = builder.build_modification_prompt(
!         champion_code=champion_code,
!         champion_metrics=champion_metrics,
!         target_metric='sharpe_ratio'
!     )
  
!     print(f"\nModification Prompt Length: {len(mod_prompt)} chars")
!     print(f"Estimated Tokens: ~{len(mod_prompt) // CHARS_PER_TOKEN}")
!     print(f"\nPrompt Preview (first 500 chars):\n{mod_prompt[:500]}...")
  
      # Test 2: Creation Prompt
!     print("\n" + "=" * 70)
!     print("Test 2: Creation Prompt")
!     print("=" * 70)
  
!     creation_prompt = builder.build_creation_prompt(
!         champion_approach="Momentum-based factor with ROE quality filter",
!         innovation_directive="Explore value + quality combinations using P/B and profit margins"
!     )
  
!     print(f"\nCreation Prompt Length: {len(creation_prompt)} chars")
!     print(f"Estimated Tokens: ~{len(creation_prompt) // CHARS_PER_TOKEN}")
!     print(f"\nPrompt Preview (first 500 chars):\n{creation_prompt[:500]}...")
  
      # Test 3: Success Factor Extraction
!     print("\n" + "=" * 70)
!     print("Test 3: Success Factor Extraction")
!     print("=" * 70)
  
!     factors = builder.extract_success_factors(champion_code, champion_metrics)
!     print(f"\nExtracted {len(factors)} success factors:")
!     for i, factor in enumerate(factors, 1):
!         print(f"  {i}. {factor}")
  
      # Test 4: Failure Pattern Extraction
!     print("\n" + "=" * 70)
!     print("Test 4: Failure Pattern Extraction")
!     print("=" * 70)
  
!     patterns = builder.extract_failure_patterns()
!     print(f"\nExtracted {len(patterns)} failure patterns")
!     if patterns:
!         print(f"\nFirst pattern:")
!         print(f"  Type: {patterns[0].get('pattern_type')}")
!         print(f"  Description: {patterns[0].get('description')}")
!         print(f"  Impact: {patterns[0].get('performance_impact', 0):.2%}")
  
!     print("\n" + "=" * 70)
!     print("PROMPT BUILDER TEST COMPLETE")
!     print("=" * 70)
