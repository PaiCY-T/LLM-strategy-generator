"""
Unit tests for ExitParameterMutator.

Tests parameter-based mutation with Gaussian noise, boundary clamping,
regex replacement, and AST validation.

Coverage Target: >90%
Success Rate Target: >70%

Test Categories:
- Gaussian noise distribution testing (statistical validation)
- Boundary clamping for all 4 parameters
- Regex replacement patterns
- AST validation
- Edge cases and error handling
"""

import ast
import pytest
import random
from typing import List

from src.mutation.exit_parameter_mutator import (
    ExitParameterMutator,
    MutationMetadata,
    ParameterMutationResult,
    PARAM_BOUNDS,
    PARAM_PATTERNS,
)


class TestExitParameterMutatorInit:
    """Test ExitParameterMutator initialization."""

    def test_init_default_params(self):
        """Test initialization with default parameters."""
        mutator = ExitParameterMutator()
        assert mutator.gaussian_std == 0.15
        assert mutator is not None

    def test_init_custom_std(self):
        """Test initialization with custom standard deviation."""
        mutator = ExitParameterMutator(gaussian_std=0.20)
        assert mutator.gaussian_std == 0.20

    def test_init_with_seed(self):
        """Test initialization with random seed for reproducibility."""
        # Reset random state for each mutator
        random.seed(42)
        mutator1 = ExitParameterMutator()
        value1 = mutator1.apply_gaussian_noise(1.0)

        random.seed(42)
        mutator2 = ExitParameterMutator()
        value2 = mutator2.apply_gaussian_noise(1.0)

        assert value1 == value2


class TestGaussianNoiseMutation:
    """Test Gaussian noise mutation distribution."""

    def test_apply_gaussian_noise_basic(self):
        """Test basic Gaussian noise application."""
        mutator = ExitParameterMutator(gaussian_std=0.15, seed=42)
        value = 0.10
        mutated = mutator.apply_gaussian_noise(value)

        # Should be different from original
        assert mutated != value
        # Should maintain reasonable range (rough check)
        assert 0.0 < mutated < 1.0

    def test_gaussian_noise_statistical_distribution(self):
        """Test Gaussian distribution over 1000 samples.

        Requirements 3.1-3.4:
        - 68% of mutations within ±15% (1 std)
        - 95% of mutations within ±30% (2 std)
        """
        mutator = ExitParameterMutator(gaussian_std=0.15, seed=42)
        value = 0.10
        num_samples = 1000

        mutations = [mutator.apply_gaussian_noise(value) for _ in range(num_samples)]

        # Calculate percentage changes
        changes = [(m - value) / value for m in mutations]

        # Count samples within 1 std (±15%)
        within_1std = sum(1 for c in changes if abs(c) <= 0.15)
        pct_within_1std = within_1std / num_samples

        # Count samples within 2 std (±30%)
        within_2std = sum(1 for c in changes if abs(c) <= 0.30)
        pct_within_2std = within_2std / num_samples

        # Allow some statistical variance (±5% tolerance)
        assert 0.63 <= pct_within_1std <= 0.73, \
            f"Expected ~68% within 1 std, got {pct_within_1std*100:.1f}%"
        assert 0.90 <= pct_within_2std <= 1.00, \
            f"Expected ~95% within 2 std, got {pct_within_2std*100:.1f}%"

    def test_gaussian_noise_preserves_scale(self):
        """Test that Gaussian noise preserves value scale."""
        mutator = ExitParameterMutator(gaussian_std=0.15, seed=42)

        # Test with different scales
        small_value = 0.01
        large_value = 0.50

        small_mutated = mutator.apply_gaussian_noise(small_value)
        large_mutated = mutator.apply_gaussian_noise(large_value)

        # Mutations should scale proportionally
        # (small values get small mutations, large values get large mutations)
        small_change = abs(small_mutated - small_value)
        large_change = abs(large_mutated - large_value)

        # Large value should have larger absolute change
        # (this is a rough heuristic, not always true but likely with seed)
        assert small_change < large_change or abs(small_change - large_change) < 0.01


class TestBoundaryClamping:
    """Test parameter boundary clamping."""

    def test_clamp_stop_loss_within_bounds(self):
        """Test clamping for stop_loss_pct within bounds."""
        mutator = ExitParameterMutator()
        value = 0.10  # Within [0.01, 0.20]

        clamped, was_clamped = mutator.clamp_to_bounds(value, "stop_loss_pct")

        assert clamped == value
        assert was_clamped is False

    def test_clamp_stop_loss_below_min(self):
        """Test clamping for stop_loss_pct below minimum."""
        mutator = ExitParameterMutator()
        value = 0.005  # Below min 0.01

        clamped, was_clamped = mutator.clamp_to_bounds(value, "stop_loss_pct")

        assert clamped == 0.01
        assert was_clamped is True

    def test_clamp_stop_loss_above_max(self):
        """Test clamping for stop_loss_pct above maximum."""
        mutator = ExitParameterMutator()
        value = 0.25  # Above max 0.20

        clamped, was_clamped = mutator.clamp_to_bounds(value, "stop_loss_pct")

        assert clamped == 0.20
        assert was_clamped is True

    def test_clamp_take_profit_within_bounds(self):
        """Test clamping for take_profit_pct within bounds."""
        mutator = ExitParameterMutator()
        value = 0.20  # Within [0.05, 0.50]

        clamped, was_clamped = mutator.clamp_to_bounds(value, "take_profit_pct")

        assert clamped == value
        assert was_clamped is False

    def test_clamp_take_profit_below_min(self):
        """Test clamping for take_profit_pct below minimum."""
        mutator = ExitParameterMutator()
        value = 0.02  # Below min 0.05

        clamped, was_clamped = mutator.clamp_to_bounds(value, "take_profit_pct")

        assert clamped == 0.05
        assert was_clamped is True

    def test_clamp_take_profit_above_max(self):
        """Test clamping for take_profit_pct above maximum."""
        mutator = ExitParameterMutator()
        value = 0.60  # Above max 0.50

        clamped, was_clamped = mutator.clamp_to_bounds(value, "take_profit_pct")

        assert clamped == 0.50
        assert was_clamped is True

    def test_clamp_trailing_stop_within_bounds(self):
        """Test clamping for trailing_stop_offset within bounds."""
        mutator = ExitParameterMutator()
        value = 0.02  # Within [0.005, 0.05]

        clamped, was_clamped = mutator.clamp_to_bounds(value, "trailing_stop_offset")

        assert clamped == value
        assert was_clamped is False

    def test_clamp_trailing_stop_below_min(self):
        """Test clamping for trailing_stop_offset below minimum."""
        mutator = ExitParameterMutator()
        value = 0.001  # Below min 0.005

        clamped, was_clamped = mutator.clamp_to_bounds(value, "trailing_stop_offset")

        assert clamped == 0.005
        assert was_clamped is True

    def test_clamp_trailing_stop_above_max(self):
        """Test clamping for trailing_stop_offset above maximum."""
        mutator = ExitParameterMutator()
        value = 0.10  # Above max 0.05

        clamped, was_clamped = mutator.clamp_to_bounds(value, "trailing_stop_offset")

        assert clamped == 0.05
        assert was_clamped is True

    def test_clamp_holding_period_within_bounds(self):
        """Test clamping for holding_period_days within bounds."""
        mutator = ExitParameterMutator()
        value = 30  # Within [1, 60]

        clamped, was_clamped = mutator.clamp_to_bounds(value, "holding_period_days")

        assert clamped == value
        assert was_clamped is False

    def test_clamp_holding_period_below_min(self):
        """Test clamping for holding_period_days below minimum."""
        mutator = ExitParameterMutator()
        value = 0  # Below min 1

        clamped, was_clamped = mutator.clamp_to_bounds(value, "holding_period_days")

        assert clamped == 1
        assert was_clamped is True

    def test_clamp_holding_period_above_max(self):
        """Test clamping for holding_period_days above maximum."""
        mutator = ExitParameterMutator()
        value = 100  # Above max 60

        clamped, was_clamped = mutator.clamp_to_bounds(value, "holding_period_days")

        assert clamped == 60
        assert was_clamped is True

    def test_clamp_unknown_parameter(self):
        """Test clamping with unknown parameter name."""
        mutator = ExitParameterMutator()
        value = 0.10

        clamped, was_clamped = mutator.clamp_to_bounds(value, "unknown_param")

        assert clamped == value
        assert was_clamped is False


class TestRegexReplacement:
    """Test regex-based parameter replacement."""

    def test_regex_replace_stop_loss_pct(self):
        """Test regex replacement for stop_loss_pct."""
        mutator = ExitParameterMutator()
        code = "stop_loss_pct = 0.10"

        new_code, replaced = mutator.regex_replace_parameter(code, "stop_loss_pct", 0.12)

        assert replaced is True
        assert "0.12" in new_code
        assert "0.10" not in new_code

    def test_regex_replace_take_profit_pct(self):
        """Test regex replacement for take_profit_pct."""
        mutator = ExitParameterMutator()
        code = "take_profit_pct = 0.20"

        new_code, replaced = mutator.regex_replace_parameter(code, "take_profit_pct", 0.25)

        assert replaced is True
        assert "0.25" in new_code
        assert "0.20" not in new_code

    def test_regex_replace_trailing_stop_offset(self):
        """Test regex replacement for trailing_stop_offset."""
        mutator = ExitParameterMutator()
        code = "trailing_stop_offset = 0.02"

        new_code, replaced = mutator.regex_replace_parameter(
            code, "trailing_stop_offset", 0.03
        )

        assert replaced is True
        assert "0.03" in new_code
        assert "0.02" not in new_code

    def test_regex_replace_holding_period_days(self):
        """Test regex replacement for holding_period_days."""
        mutator = ExitParameterMutator()
        code = "holding_period_days = 30"

        new_code, replaced = mutator.regex_replace_parameter(
            code, "holding_period_days", 45
        )

        assert replaced is True
        assert "45" in new_code
        assert "30" not in new_code

    def test_regex_replace_with_whitespace_variations(self):
        """Test regex replacement with various whitespace patterns."""
        mutator = ExitParameterMutator()

        # Test different whitespace patterns
        test_cases = [
            "stop_loss_pct = 0.10",
            "stop_loss_pct=0.10",
            "stop_loss_pct  =  0.10",
            "stop_loss_pct\t=\t0.10",
        ]

        for code in test_cases:
            new_code, replaced = mutator.regex_replace_parameter(
                code, "stop_loss_pct", 0.12
            )
            assert replaced is True, f"Failed for: {repr(code)}"
            assert "0.12" in new_code

    def test_regex_replace_parameter_not_found(self):
        """Test regex replacement when parameter not found."""
        mutator = ExitParameterMutator()
        code = "some_other_param = 0.10"

        new_code, replaced = mutator.regex_replace_parameter(
            code, "stop_loss_pct", 0.12
        )

        assert replaced is False
        assert new_code == code  # Unchanged

    def test_regex_replace_unknown_parameter(self):
        """Test regex replacement with unknown parameter name."""
        mutator = ExitParameterMutator()
        code = "stop_loss_pct = 0.10"

        new_code, replaced = mutator.regex_replace_parameter(
            code, "unknown_param", 0.12
        )

        assert replaced is False
        assert new_code == code  # Unchanged

    def test_regex_replace_preserves_context(self):
        """Test that regex replacement preserves surrounding code."""
        mutator = ExitParameterMutator()
        code = """
def exit_strategy():
    stop_loss_pct = 0.10
    take_profit_pct = 0.20
    return stop_loss_pct, take_profit_pct
"""

        new_code, replaced = mutator.regex_replace_parameter(
            code, "stop_loss_pct", 0.12
        )

        assert replaced is True
        assert "def exit_strategy():" in new_code
        assert "take_profit_pct = 0.20" in new_code
        assert "return stop_loss_pct, take_profit_pct" in new_code
        assert "0.12" in new_code


class TestASTValidation:
    """Test AST validation of mutated code."""

    def test_validate_mutation_valid_code(self):
        """Test validation with valid Python code."""
        mutator = ExitParameterMutator()
        code = "stop_loss_pct = 0.12"

        valid = mutator.validate_mutation(code)

        assert valid is True

    def test_validate_mutation_complex_valid_code(self):
        """Test validation with complex valid Python code."""
        mutator = ExitParameterMutator()
        code = """
def exit_strategy():
    stop_loss_pct = 0.12
    take_profit_pct = 0.25
    if stop_loss_pct > 0:
        return True
    return False
"""

        valid = mutator.validate_mutation(code)

        assert valid is True

    def test_validate_mutation_syntax_error(self):
        """Test validation with syntax error."""
        mutator = ExitParameterMutator()
        code = "stop_loss_pct = "  # Incomplete assignment

        valid = mutator.validate_mutation(code)

        assert valid is False

    def test_validate_mutation_invalid_python(self):
        """Test validation with invalid Python."""
        mutator = ExitParameterMutator()
        code = "this is not valid python code @ $ %"

        valid = mutator.validate_mutation(code)

        assert valid is False


class TestMutateExitParameters:
    """Test full mutation pipeline."""

    def test_mutate_specific_parameter_success(self):
        """Test mutation of specific parameter."""
        mutator = ExitParameterMutator(seed=42)
        code = "stop_loss_pct = 0.10"

        result = mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")

        assert result.success is True
        assert result.validation_passed is True
        assert result.metadata is not None
        assert result.metadata.parameter_name == "stop_loss_pct"
        assert result.metadata.old_value == 0.10
        assert result.metadata.new_value != 0.10  # Should be mutated
        # Check that new value is in result code
        assert f"{result.metadata.new_value:.2f}" in result.code

    def test_mutate_random_parameter(self):
        """Test mutation with random parameter selection."""
        mutator = ExitParameterMutator(seed=42)
        code = """
stop_loss_pct = 0.10
take_profit_pct = 0.20
"""

        result = mutator.mutate_exit_parameters(code)

        assert result.success is True
        assert result.validation_passed is True
        assert result.metadata is not None
        assert result.metadata.parameter_name in ["stop_loss_pct", "take_profit_pct"]

    def test_mutate_all_parameters_individually(self):
        """Test mutation of all 4 parameters."""
        code = """
stop_loss_pct = 0.10
take_profit_pct = 0.20
trailing_stop_offset = 0.02
holding_period_days = 30
"""

        for param_name in PARAM_BOUNDS.keys():
            mutator = ExitParameterMutator(seed=42)
            result = mutator.mutate_exit_parameters(code, parameter_name=param_name)

            assert result.success is True, f"Failed for {param_name}"
            assert result.validation_passed is True
            assert result.metadata.parameter_name == param_name

    def test_mutate_clamping_occurs(self):
        """Test that clamping occurs for extreme mutations."""
        # Use high std to force clamping
        mutator = ExitParameterMutator(gaussian_std=5.0, seed=42)
        code = "stop_loss_pct = 0.10"

        # Run multiple times to increase chance of clamping
        clamped_found = False
        for _ in range(20):
            result = mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")
            if result.metadata and result.metadata.clamped:
                clamped_found = True
                break

        assert clamped_found, "Expected to find at least one clamped mutation"

    def test_mutate_parameter_not_found(self):
        """Test mutation when parameter not found in code."""
        mutator = ExitParameterMutator()
        code = "some_other_param = 0.10"

        result = mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")

        assert result.success is False
        assert result.metadata is not None
        assert "not found" in result.metadata.error

    def test_mutate_no_parameters_in_code(self):
        """Test mutation when no exit parameters in code."""
        mutator = ExitParameterMutator()
        code = "x = 1 + 1"

        result = mutator.mutate_exit_parameters(code)

        assert result.success is False
        assert result.metadata is None

    def test_mutate_unknown_parameter_name(self):
        """Test mutation with unknown parameter name."""
        mutator = ExitParameterMutator()
        code = "stop_loss_pct = 0.10"

        result = mutator.mutate_exit_parameters(code, parameter_name="unknown_param")

        assert result.success is False
        assert result.metadata is not None
        assert "Unknown parameter" in result.metadata.error

    def test_mutate_preserves_code_structure(self):
        """Test that mutation preserves overall code structure."""
        mutator = ExitParameterMutator(seed=42)
        code = """
def my_strategy():
    # Exit parameters
    stop_loss_pct = 0.10
    take_profit_pct = 0.20

    # Some logic
    if stop_loss_pct > 0:
        return True

    return False
"""

        result = mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")

        assert result.success is True
        assert "def my_strategy():" in result.code
        assert "# Exit parameters" in result.code
        assert "if stop_loss_pct > 0:" in result.code
        assert "return False" in result.code


class TestSuccessRateValidation:
    """Test success rate meets >70% target."""

    def test_success_rate_with_real_strategy_code(self):
        """Test success rate on realistic strategy code.

        Target: >70% success rate (vs 0% baseline from AST approach)
        """
        mutator = ExitParameterMutator()

        # Realistic strategy code template
        strategy_template = """
def exit_strategy(data):
    # Exit parameters
    stop_loss_pct = 0.10
    take_profit_pct = 0.20
    trailing_stop_offset = 0.02
    holding_period_days = 30

    # Calculate exit conditions
    if data['loss'] > stop_loss_pct:
        return 'stop_loss'
    if data['profit'] > take_profit_pct:
        return 'take_profit'

    return 'hold'
"""

        num_mutations = 100
        successes = 0

        for i in range(num_mutations):
            # Use different seeds for variety
            mutator_run = ExitParameterMutator(seed=i)
            result = mutator_run.mutate_exit_parameters(strategy_template)

            if result.success:
                successes += 1

        success_rate = successes / num_mutations

        # Assert >70% success rate
        assert success_rate >= 0.70, \
            f"Success rate {success_rate*100:.1f}% below target 70%"

        # Print for visibility
        print(f"\nSuccess rate: {success_rate*100:.1f}% ({successes}/{num_mutations})")

    def test_success_rate_per_parameter(self):
        """Test success rate for each parameter individually."""
        strategy_code = """
stop_loss_pct = 0.10
take_profit_pct = 0.20
trailing_stop_offset = 0.02
holding_period_days = 30
"""

        num_trials = 50

        for param_name in PARAM_BOUNDS.keys():
            successes = 0

            for i in range(num_trials):
                mutator = ExitParameterMutator(seed=i)
                result = mutator.mutate_exit_parameters(
                    strategy_code,
                    parameter_name=param_name
                )

                if result.success:
                    successes += 1

            success_rate = successes / num_trials

            assert success_rate >= 0.70, \
                f"{param_name} success rate {success_rate*100:.1f}% below target 70%"


class TestHelperMethods:
    """Test helper methods."""

    def test_detect_available_parameters_all(self):
        """Test detection of all available parameters."""
        mutator = ExitParameterMutator()
        code = """
stop_loss_pct = 0.10
take_profit_pct = 0.20
trailing_stop_offset = 0.02
holding_period_days = 30
"""

        available = mutator._detect_available_parameters(code)

        assert len(available) == 4
        assert "stop_loss_pct" in available
        assert "take_profit_pct" in available
        assert "trailing_stop_offset" in available
        assert "holding_period_days" in available

    def test_detect_available_parameters_partial(self):
        """Test detection with only some parameters present."""
        mutator = ExitParameterMutator()
        code = """
stop_loss_pct = 0.10
take_profit_pct = 0.20
"""

        available = mutator._detect_available_parameters(code)

        assert len(available) == 2
        assert "stop_loss_pct" in available
        assert "take_profit_pct" in available
        assert "trailing_stop_offset" not in available
        assert "holding_period_days" not in available

    def test_detect_available_parameters_none(self):
        """Test detection with no exit parameters."""
        mutator = ExitParameterMutator()
        code = "x = 1 + 1"

        available = mutator._detect_available_parameters(code)

        assert len(available) == 0

    def test_extract_parameter_value_success(self):
        """Test parameter value extraction."""
        mutator = ExitParameterMutator()
        code = "stop_loss_pct = 0.12"

        value = mutator._extract_parameter_value(code, "stop_loss_pct")

        assert value == 0.12

    def test_extract_parameter_value_not_found(self):
        """Test parameter value extraction when not found."""
        mutator = ExitParameterMutator()
        code = "some_other_param = 0.10"

        value = mutator._extract_parameter_value(code, "stop_loss_pct")

        assert value is None

    def test_extract_parameter_value_integer(self):
        """Test extraction of integer parameter."""
        mutator = ExitParameterMutator()
        code = "holding_period_days = 30"

        value = mutator._extract_parameter_value(code, "holding_period_days")

        assert value == 30.0  # Converted to float


class TestEdgeCases:
    """Test edge cases and error handling."""

    def test_zero_value_parameter(self):
        """Test mutation with zero value parameter."""
        mutator = ExitParameterMutator(seed=42)
        code = "stop_loss_pct = 0.0"

        result = mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")

        # Should clamp to minimum bound
        assert result.success is True
        assert result.metadata.new_value >= 0.01  # Min bound

    def test_negative_value_parameter(self):
        """Test mutation with negative value (should clamp to min)."""
        mutator = ExitParameterMutator()
        # Negative values won't match the regex pattern [\d.]+, so this test
        # should verify that mutation handles non-matching patterns gracefully
        code = "stop_loss_pct = -0.05"

        result = mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")

        # Negative value won't be matched by regex, so mutation should fail gracefully
        assert result.success is False
        assert result.metadata is not None
        assert "not found" in result.metadata.error

    def test_very_large_value_parameter(self):
        """Test mutation with very large value (should clamp to max)."""
        mutator = ExitParameterMutator()
        code = "stop_loss_pct = 10.0"

        result = mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")

        # Should clamp to maximum bound after mutation
        assert result.success is True
        assert result.metadata.new_value <= 0.20  # Max bound

    def test_multiple_same_parameter_occurrences(self):
        """Test code with multiple occurrences of same parameter."""
        mutator = ExitParameterMutator(seed=42)
        code = """
stop_loss_pct = 0.10
# Later override
stop_loss_pct = 0.12
"""

        result = mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")

        # Should replace first occurrence
        assert result.success is True


class TestTask22BoundaryEnforcement:
    """
    Task 2.2: Comprehensive boundary enforcement tests.

    Tests all 4 exit parameters for min/max bounds, integer rounding,
    and logging verification when clamping occurs.
    """

    def test_stop_loss_min_bound(self):
        """Test stop_loss_pct minimum boundary enforcement."""
        mutator = ExitParameterMutator()
        value = 0.005  # Below min 0.01

        clamped, was_clamped = mutator.clamp_to_bounds(value, "stop_loss_pct")

        assert clamped == 0.01, f"Expected 0.01, got {clamped}"
        assert was_clamped is True, "Should be flagged as clamped"

    def test_stop_loss_max_bound(self):
        """Test stop_loss_pct maximum boundary enforcement."""
        mutator = ExitParameterMutator()
        value = 0.25  # Above max 0.20

        clamped, was_clamped = mutator.clamp_to_bounds(value, "stop_loss_pct")

        assert clamped == 0.20, f"Expected 0.20, got {clamped}"
        assert was_clamped is True, "Should be flagged as clamped"

    def test_take_profit_min_bound(self):
        """Test take_profit_pct minimum boundary enforcement."""
        mutator = ExitParameterMutator()
        value = 0.02  # Below min 0.05

        clamped, was_clamped = mutator.clamp_to_bounds(value, "take_profit_pct")

        assert clamped == 0.05, f"Expected 0.05, got {clamped}"
        assert was_clamped is True, "Should be flagged as clamped"

    def test_take_profit_max_bound(self):
        """Test take_profit_pct maximum boundary enforcement."""
        mutator = ExitParameterMutator()
        value = 0.60  # Above max 0.50

        clamped, was_clamped = mutator.clamp_to_bounds(value, "take_profit_pct")

        assert clamped == 0.50, f"Expected 0.50, got {clamped}"
        assert was_clamped is True, "Should be flagged as clamped"

    def test_trailing_stop_min_bound(self):
        """Test trailing_stop_offset minimum boundary enforcement."""
        mutator = ExitParameterMutator()
        value = 0.001  # Below min 0.005

        clamped, was_clamped = mutator.clamp_to_bounds(value, "trailing_stop_offset")

        assert clamped == 0.005, f"Expected 0.005, got {clamped}"
        assert was_clamped is True, "Should be flagged as clamped"

    def test_trailing_stop_max_bound(self):
        """Test trailing_stop_offset maximum boundary enforcement."""
        mutator = ExitParameterMutator()
        value = 0.10  # Above max 0.05

        clamped, was_clamped = mutator.clamp_to_bounds(value, "trailing_stop_offset")

        assert clamped == 0.05, f"Expected 0.05, got {clamped}"
        assert was_clamped is True, "Should be flagged as clamped"

    def test_holding_period_min_bound(self):
        """Test holding_period_days minimum boundary enforcement."""
        mutator = ExitParameterMutator()
        value = 0  # Below min 1

        clamped, was_clamped = mutator.clamp_to_bounds(value, "holding_period_days")

        assert clamped == 1, f"Expected 1, got {clamped}"
        assert was_clamped is True, "Should be flagged as clamped"
        assert isinstance(clamped, int), "Should be integer type"

    def test_holding_period_max_bound(self):
        """Test holding_period_days maximum boundary enforcement."""
        mutator = ExitParameterMutator()
        value = 100  # Above max 60

        clamped, was_clamped = mutator.clamp_to_bounds(value, "holding_period_days")

        assert clamped == 60, f"Expected 60, got {clamped}"
        assert was_clamped is True, "Should be flagged as clamped"
        assert isinstance(clamped, int), "Should be integer type"

    def test_holding_period_integer_rounding_up(self):
        """Test holding_period_days rounds up from 0.5 or above."""
        mutator = ExitParameterMutator()

        # Test rounding up
        value = 14.7
        clamped, was_clamped = mutator.clamp_to_bounds(value, "holding_period_days")

        assert clamped == 15, f"Expected 14.7 to round to 15, got {clamped}"
        assert isinstance(clamped, int), "Should be integer type"
        # Note: was_clamped will be False since rounding is different from clamping

    def test_holding_period_integer_rounding_down(self):
        """Test holding_period_days rounds down from below 0.5."""
        mutator = ExitParameterMutator()

        # Test rounding down
        value = 14.3
        clamped, was_clamped = mutator.clamp_to_bounds(value, "holding_period_days")

        assert clamped == 14, f"Expected 14.3 to round to 14, got {clamped}"
        assert isinstance(clamped, int), "Should be integer type"

    def test_clamping_logged(self, caplog):
        """Test that clamping events are logged at INFO level."""
        import logging

        mutator = ExitParameterMutator()
        code = "stop_loss_pct = 0.005"  # Below minimum, will be clamped

        with caplog.at_level(logging.INFO):
            result = mutator.mutate(code, param_name="stop_loss_pct")

        # Verify logging occurred
        assert any("clamped" in record.message.lower() for record in caplog.records), \
            "Expected clamping to be logged at INFO level"

        # Verify the mutation succeeded with clamping
        if result.success:
            assert result.metadata["bounded"] is True, "Metadata should indicate clamping"

    def test_all_parameters_within_bounds_no_clamping(self):
        """Test that values within bounds are not clamped."""
        mutator = ExitParameterMutator()

        test_cases = [
            ("stop_loss_pct", 0.10),      # Within [0.01, 0.20]
            ("take_profit_pct", 0.25),     # Within [0.05, 0.50]
            ("trailing_stop_offset", 0.02), # Within [0.005, 0.05]
            ("holding_period_days", 30),    # Within [1, 60]
        ]

        for param_name, value in test_cases:
            clamped, was_clamped = mutator.clamp_to_bounds(value, param_name)

            assert clamped == value, \
                f"{param_name}: Expected {value}, got {clamped} (should not clamp)"
            assert was_clamped is False, \
                f"{param_name}: Should not be flagged as clamped for value {value}"

    def test_boundary_compliance_100_percent(self):
        """Test 100% boundary compliance across multiple mutations."""
        mutator = ExitParameterMutator(gaussian_std_dev=2.0)  # High std to force extreme values
        code = """
stop_loss_pct = 0.10
take_profit_pct = 0.20
trailing_stop_offset = 0.02
holding_period_days = 30
"""

        violations = 0
        total_mutations = 100

        for _ in range(total_mutations):
            # Try each parameter
            for param_name in ["stop_loss_pct", "take_profit_pct",
                             "trailing_stop_offset", "holding_period_days"]:
                result = mutator.mutate(code, param_name=param_name)

                if result.success:
                    new_value = result.metadata["new_value"]
                    bounds = mutator.PARAM_BOUNDS[param_name]

                    # Check if value is within bounds
                    if new_value < bounds.min_value or new_value > bounds.max_value:
                        violations += 1

        # Assert 100% compliance (0 violations)
        assert violations == 0, \
            f"Found {violations} boundary violations in {total_mutations} mutations"


class TestMetadataAndResults:
    """Test metadata and result objects."""

    def test_mutation_metadata_repr(self):
        """Test MutationMetadata repr."""
        metadata = MutationMetadata(
            parameter_name="stop_loss_pct",
            old_value=0.10,
            new_value=0.12,
            clamped=False,
            success=True
        )

        repr_str = repr(metadata)

        assert "stop_loss_pct" in repr_str
        assert "0.1000" in repr_str
        assert "0.1200" in repr_str
        assert "SUCCESS" in repr_str

    def test_mutation_metadata_clamped_repr(self):
        """Test MutationMetadata repr with clamping."""
        metadata = MutationMetadata(
            parameter_name="stop_loss_pct",
            old_value=0.10,
            new_value=0.20,
            clamped=True,
            success=True
        )

        repr_str = repr(metadata)

        assert "CLAMPED" in repr_str

    def test_parameter_mutation_result_repr(self):
        """Test ParameterMutationResult repr."""
        result = ParameterMutationResult(
            success=True,
            code="stop_loss_pct = 0.12",
            metadata=None,
            validation_passed=True
        )

        repr_str = repr(result)

        assert "SUCCESS" in repr_str
        assert "VALIDATED" in repr_str


# Performance and benchmarking tests
class TestPerformance:
    """Test performance requirements."""

    def test_mutation_latency(self):
        """Test that mutation completes within 100ms target."""
        import time

        mutator = ExitParameterMutator()
        code = """
stop_loss_pct = 0.10
take_profit_pct = 0.20
trailing_stop_offset = 0.02
holding_period_days = 30
"""

        # Warm-up
        mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")

        # Measure
        start = time.perf_counter()
        result = mutator.mutate_exit_parameters(code, parameter_name="stop_loss_pct")
        end = time.perf_counter()

        latency_ms = (end - start) * 1000

        assert result.success is True
        assert latency_ms < 100, f"Mutation took {latency_ms:.2f}ms, exceeds 100ms target"

    def test_regex_matching_performance(self):
        """Test that regex matching completes within 10ms target."""
        import time

        mutator = ExitParameterMutator()
        code = "stop_loss_pct = 0.10"

        # Warm-up
        mutator._extract_parameter_value(code, "stop_loss_pct")

        # Measure
        start = time.perf_counter()
        value = mutator._extract_parameter_value(code, "stop_loss_pct")
        end = time.perf_counter()

        latency_ms = (end - start) * 1000

        assert value == 0.10
        assert latency_ms < 10, f"Regex matching took {latency_ms:.2f}ms, exceeds 10ms target"
