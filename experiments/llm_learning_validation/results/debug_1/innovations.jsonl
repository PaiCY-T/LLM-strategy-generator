{"iteration_num": 0, "generation_method": "llm", "strategy_code": "def strategy(data):\n    # --- Data Loading and Preprocessing ---\n    # Load adjusted close price for momentum calculation and liquidity filter\n    close = data.get('etl:adj_close')\n    # Load trading value for liquidity filter\n    trading_value = data.get('price:成交金額')\n    # Load operating margin for quality filtering (profitability)\n    operating_margin = data.get('fundamental_features:營業利益率')\n    # Load PB ratio for value filtering\n    pb_ratio = data.get('price_earning_ratio:股價淨值比')\n    # Load market value for size filtering (optional, but good for robustness)\n    market_value = data.get('etl:market_value')\n\n    # --- Liquidity Filter ---\n    # Ensure sufficient liquidity: average daily trading value > 150M TWD over 20 days\n    # Use shift(1) to avoid look-ahead bias for past trading value\n    liquidity_filter = trading_value.rolling(20).mean().shift(1) > 150_000_000\n    liquidity_filter = liquidity_filter.fillna(False) # Fill NaN with False\n\n    # --- Momentum Factor (Preserving successful pattern) ---\n    # Calculate 20-day price momentum (return)\n    # Use shift(1) to ensure momentum is calculated from past data\n    momentum_20d = (close.shift(1) / close.shift(21) - 1).fillna(0)\n\n    # Calculate 5-day price momentum (short-term)\n    momentum_5d = (close.shift(1) / close.shift(6) - 1).fillna(0)\n\n    # --- Quality Factor (Improving with Operating Margin) ---\n    # Filter for companies with consistently high operating margins\n    # Use shift(1) for fundamental data to avoid look-ahead bias\n    # Use a rolling median to smooth out quarterly fluctuations and capture consistency\n    # High operating margin indicates strong business fundamentals\n    quality_filter = operating_margin.shift(1).rolling(window=4, min_periods=1).median() > 0.05 # Top 5% operating margin\n\n    # --- Value Factor (Using PB Ratio) ---\n    # Filter for companies with reasonable PB ratio (not too high, not too low)\n    # Low PB can indicate value, but too low might be a value trap\n    # Use shift(1)\n    pb_filter = (pb_ratio.shift(1) > 0.8) & (pb_ratio.shift(1) < 3.0) # Avoid extreme low/high PB\n\n    # --- Cross-sectional Ranking (Preserving successful pattern) ---\n    # Rank stocks based on 20-day momentum\n    # Use .rank(axis=1, ascending=False) to rank from highest momentum to lowest\n    momentum_rank = momentum_20d.rank(axis=1, ascending=False, pct=True)\n\n    # Combine short-term and long-term momentum with a weighted average\n    # Give more weight to longer-term momentum for stability\n    combined_momentum = (momentum_20d * 0.7 + momentum_5d * 0.3)\n    combined_momentum_rank = combined_momentum.rank(axis=1, ascending=False, pct=True)\n\n    # --- Selection Criteria ---\n    # Select top N% by combined momentum rank\n    # Also apply quality, value, and liquidity filters\n    # Target top 20% by momentum (0.2)\n    selection = (combined_momentum_rank < 0.2) & \\\n                quality_filter & \\\n                pb_filter & \\\n                liquidity_filter\n\n    # --- Position Sizing ---\n    # Equal weight for selected stocks\n    # Handle cases where no stocks are selected\n    position = selection.astype(float).div(selection.sum(axis=1), axis=0).fillna(0)\n\n    return position\n\n# --- Backtest Execution (REQUIRED) ---\n# Assuming 'data' object, 'start_date', 'end_date', 'fee_ratio', 'tax_ratio', 'sim' are defined in the environment.\n# This part is for FinLab platform execution, so these variables are typically provided.\n\n# Example placeholder for definition of data, start_date, end_date, etc. if running locally for testing\n# For actual FinLab backtest, these are pre-defined.\n# from finlab import data\n# from finlab.backtest import sim\n# data = data.get_data() # This would load all necessary data\n# start_date = '2010-01-01'\n# end_date = '2023-12-31'\n# fee_ratio = 1.425/1000 * 2 # Transaction fees (buy and sell)\n# tax_ratio = 3/1000 # Transaction tax for selling stocks\n\nposition = strategy(data)\nposition = position.loc[start_date:end_date]\nreport = sim(\n    position,\n    fee_ratio=fee_ratio,\n    tax_ratio=tax_ratio,\n    resample=\"M\"\n)", "strategy_id": null, "strategy_generation": null, "execution_result": {"success": true, "error_type": null, "error_message": null, "execution_time": 17.08868098258972, "sharpe_ratio": 0.4225471143553446, "total_return": 0.8350246553630905, "max_drawdown": -0.4210544916278658, "report": null, "stack_trace": null}, "metrics": {"sharpe_ratio": 0.4225471143553446, "total_return": 0.8350246553630905, "max_drawdown": -0.4210544916278658, "win_rate": null, "execution_success": true}, "classification_level": "LEVEL_3", "timestamp": "2025-11-15T22:39:43.999902", "champion_updated": false, "feedback_used": "First iteration - no previous history. Generate a basic momentum strategy."}
