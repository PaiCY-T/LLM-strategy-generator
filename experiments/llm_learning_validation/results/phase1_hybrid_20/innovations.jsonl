{"iteration_num": 0, "generation_method": "factor_graph", "strategy_code": null, "strategy_id": "template_0", "strategy_generation": 0, "execution_result": {"success": true, "error_type": null, "error_message": null, "execution_time": 15.875906944274902, "sharpe_ratio": 0.30116893698536307, "total_return": 0.41634872158815317, "max_drawdown": -0.32238065647715797, "report": null, "stack_trace": null}, "metrics": {"sharpe_ratio": 0.30116893698536307, "total_return": 0.41634872158815317, "max_drawdown": -0.32238065647715797, "win_rate": null, "execution_success": true}, "classification_level": "LEVEL_3", "timestamp": "2025-11-20T23:37:16.698206", "champion_updated": false, "feedback_used": "First iteration - no previous history. Generate a basic momentum strategy."}
{"iteration_num": 1, "generation_method": "llm", "strategy_code": "import pandas as pd\n\ndef strategy(data):\n    # --- 1. Data Loading and Preprocessing ---\n    # Load necessary data fields, using .shift(1) to prevent look-ahead bias\n    close = data.get('price:收盤價')\n    trading_value = data.get('price:成交金額')\n    operating_margin = data.get('fundamental_features:營業利益率').shift(1)\n    pb_ratio = data.get('fundamental_features:股價淨值比').shift(1)\n    # Using 'financial_statement:銷貨收入' for revenue and 'financial_statement:銷貨毛利' for gross profit\n    # to calculate gross margin, which is a good indicator of profitability and pricing power.\n    revenue = data.get('financial_statement:銷貨收入').shift(1)\n    gross_profit = data.get('financial_statement:銷貨毛利').shift(1)\n    \n    # Calculate 20-day and 60-day moving averages for momentum\n    ma_20 = close.rolling(20).mean()\n    ma_60 = close.rolling(60).mean()\n\n    # --- 2. Liquidity Filter ---\n    # Preserve liquidity requirements (>150M TWD average daily trading value over 20 days)\n    avg_trading_value = trading_value.rolling(20).mean()\n    liquidity_filter = (avg_trading_value > 150_000_000)\n\n    # --- 3. Momentum and Trend Following Filter ---\n    # Price momentum: current price > 20-day MA > 60-day MA\n    # This indicates a strong upward trend.\n    momentum_filter = (close > ma_20) & (ma_20 > ma_60)\n\n    # Calculate 20-day price change for additional momentum signal\n    price_change_20d = close.pct_change(20)\n    # Rank stocks by 20-day price change cross-sectionally\n    momentum_rank = price_change_20d.rank(axis=1, ascending=False, pct=True)\n    top_momentum = (momentum_rank <= 0.2) # Select top 20% by momentum\n\n    # --- 4. Quality and Value Filters (Enhanced) ---\n    # Enhance operating margin filter: high profitability\n    # Use gross margin as an additional quality indicator\n    gross_margin = (gross_profit / revenue).replace([float('inf'), -float('inf')], pd.NA).fillna(0) # Handle potential division by zero\n    quality_filter = (operating_margin > 0.05) & (gross_margin > 0.15) # Operating margin > 5%, Gross margin > 15%\n\n    # Value filter: low PB ratio\n    value_filter = (pb_ratio < 2.0) & (pb_ratio > 0.5) # Avoid extremely low PB which might indicate distress\n\n    # --- 5. Combine Filters ---\n    # Combine liquidity, strong trend, top momentum, quality, and value\n    # Prioritize strong trend and momentum while ensuring quality and reasonable valuation\n    combined_filter = liquidity_filter & momentum_filter & top_momentum & quality_filter & value_filter\n\n    # --- 6. Position Sizing (Optional, for boolean series, just return the filter) ---\n    # For this strategy, a boolean series is sufficient for stock selection.\n    # If we wanted to rank and select a fixed number of stocks, we would use rank() and nlargest().\n    \n    # Fill NaN values with False to ensure no stock is selected if data is missing\n    position = combined_filter.fillna(False)\n\n    return position\n\n# --- Backtest Execution ---\n# Assume 'data' is provided by the FinLab backtesting environment\n# Assume 'start_date', 'end_date', 'fee_ratio', 'tax_ratio', 'sim' are defined in the environment\n\n# Example placeholder for backtesting (will be filled by FinLab environment)\n# For local testing, you would need to define data, start_date, end_date, etc.\n# For FinLab platform, these are pre-defined.\n\n# position = strategy(data)\n# position = position.loc[start_date:end_date]\n# report = sim(\n#     position,\n#     fee_ratio=fee_ratio,\n#     tax_ratio=tax_ratio,\n#     resample=\"M\"\n# )", "strategy_id": null, "strategy_generation": null, "execution_result": {"success": false, "error_type": "ValueError", "error_message": "Strategy code did not create 'report' variable. Ensure code calls sim() and assigns result to 'report'.", "execution_time": 0.0022127628326416016, "sharpe_ratio": null, "total_return": null, "max_drawdown": null, "report": null, "stack_trace": null}, "metrics": {"sharpe_ratio": null, "total_return": null, "max_drawdown": null, "win_rate": null, "execution_success": false}, "classification_level": "LEVEL_0", "timestamp": "2025-11-20T23:37:23.812632", "champion_updated": false, "feedback_used": "Iteration 1: EXECUTION ERROR\n\nError: Unknown error\n\nCommon causes:\n- Data access errors (check data.get() calls)\n- Type errors (verify operations)\n- Division by zero\n- Missing dependencies\n\nDebugging:\n- Review error message carefully\n- Check data availability\n- Verify all operations\n\nNo recent successful iterations. Review fundamentals.\n"}
